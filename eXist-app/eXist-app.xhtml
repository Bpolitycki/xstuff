<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Creating an eXist-db application</title>
        <link rel="stylesheet" type="text/css" href="http://www.obdurodon.org/css/style.css" />
        <style type="text/css">
            code,
            pre {
                font-size: 85%;
            }
            q {
                font-style: regular;
            }
            h1 {
                counter-reset: h2;
            }
            .unnumbered:before {
                /* setting display to none both suppresses output and removes the element from the count */
                display: none;
            }
            h2:before {
                counter-increment: h2;
                content: counter(h2) '. ';
            }
            h2 {
                counter-reset: h3;
            }
            h3:before {
                counter-increment: h3;
                content: counter(h2) '.' counter(h3) '. ';
            }
            h3 {
                counter-reset: h4;
            }
            h4:before {
                counter-increment: h4;
                content: counter(h2) '.' counter(h3) '.' counter(h4) '. '}</style>
        <!-- Markup based on eXist boook, p. 12
                
                Italic: Indicates new terms, URLs, email addresses, file- and pathnames, 
                database collections, and file extensions. Here: <i> ... </i>
                
                Constant width: Used for program listings, as well as within paragraphs to 
                refer to program elements such as variable or function names, module names, 
                data types, environment variables, statements, and keywords. Also used for 
                commands and command-line output, database user and group names, and permission 
                modes. Here: <code> ... </code>
                
                Constant width italic: Shows text that should be replaced with user-supplied 
                values or by values determined by context. Here: <code><i> ... </i></code>.
                
                Added: 
                    Values chosen or entered by users are tagged a <q> ... </q>; this includes
                        the names of buttons. This styling overrides other markup, e.g., if the user 
                        is to enter a filename or a user or group name, it is quoted but not italic 
                        or constant width.
                    The name eXist-db is used (instead of just eXist).
                    Names of programs (e.g., eXist, eXide) are not styled. Neither are names of
                        dialogs (e.g., Open . document), the labels on dialog widgets (e.g., Template),
                        or menu items (e.g., Application or New application).
            -->
    </head>
    <body>
        <h1>Creating an eXist-db application</h1>
        <p>David J. Birnbaum, last revised 2018-12-01, CC-BY-SA</p>
        <section id="introduction">
            <h2 class="unnumbered">Introduction</h2>
            <p>This tutorial describes the steps involved in creating an application within
                eXist-db. This method uses eXist-db not only as an XML database, but also as a
                content management system (CMS), which means that all application resources (for the
                model, controller, and view) are packaged into a single <i>.xar</i> file that can be
                hot-deployed into any running eXist-db instance. This type of app provides a
                self-contained alternative to the familiar architecture in which an HTML/PHP front
                end, typically running on an Apache or Nginx HTTP server, queries eXist-db only to
                retrieve information, but otherwise manages the front end itself, including both
                accepting user input and formatting output (for more information about this approach
                see <a href="http://dh.obdurodon.org/php-xquery.xhtml"
                    >http://dh.obdurodon.org/php-xquery.xhtml</a>). The principal advantage of the
                eXist-db app architecture described here is greater ease of maintenance and
                deployment, since there is no dependency on communication with an independent web
                server. The principal disadvantage of the eXist-db app approach is greater
                dependence on eXist-db, since much of the eXist-db app functionality is specific to
                eXist-db, and cannot be transferred directly, without modification, into an
                alternative XML database. The difference between the eXist-db app and the HTML/PHP
                architecture lies ultimately in the extent of the dependency, which is present to
                some measure in any case because not all aspects of interacting with an XML database
                are addressed in the standards to which all XML databases seek to conform.</p>
            <p>eXist-db incorporates support for two further aspects of app development that are not
                addressed in this tutorial. One is that the eXide app wizard within eXist-db enables
                the configuration of Bootstrap CSS support within a new eXist-db app. We prefer not
                to use Bootstrap (in this tutorial and in our real work) because we have better
                control over styling when we manage all CSS directly ourselves. The other is that
                eXist-db supports an HTML templating framework, which, in MVC terminology, separates
                the view more clearly from the controller than we do in the process described below.
                We avoid HTML templating in order to control includes more explicitly, at the cost
                of having to incorporate more configuration information in our XQuery scripts. Users
                who prefer to avail themselves of Bootstrap or templating can learn more about them
                in the following sources, which are recommended reading in any case:</p>
            <ul>
                <li><a href="http://exist-db.org/exist/apps/doc/development-starter"
                        >http://exist-db.org/exist/apps/doc/development-starter</a>, which
                    introduces eXist-db app development. This page can be consulted together with <a
                        href="http://exist-db.org/exist/apps/doc/templating.xml"
                        >http://exist-db.org/exist/apps/doc/templating.xml</a>, which introduces and
                    describes HTML templating.</li>
                <li>Chapter 9, <q>Building applications</q>, of Erik Siegel and Adam Retter’s
                        <cite>eXist</cite>, Beijing et al.: O’Reilly, 2014, pp. 191–235. This book
                    is referred to below as <q>Siegel and Retter</q>.</li>
            </ul>
            <p>The stages in the procedure for developing an eXist-db app are described below in the
                following order:</p>
            <ol>
                <li><a href="#skeleton">Create a new app skeleton</a></li>
                <li><a href="#directories">Expand the skeleton</a></li>
                <li><a href="#content">Add XML content and non-XML resources</a></li>
                <li><a href="#indexing">Add support for indexing</a></li>
                <li><a href="#xquery">Create some XQuery scripts</a></li>
                <li><a href="#xinclude">Modularize with XInclude</a></li>
                <li><a href="#controller">Configure <i>controller.xql</i></a></li>
                <li><a href="#xslt">Transform to HTML with XSLT</a></li>
                <li><a href="#generate">Generate your app</a></li>
            </ol>
            <p>The code that produces the table of variables and function values at the top of the
                    <a href="#controller_example">Examining controller variables and
                        <code>request:</code> function values</a> section, below, is available in <a
                    href="#variable_output">Appendix A: Controller variables and
                        <code>request:</code> functions</a>. <a href="#paths">Appendix B: Path
                    summary</a>, compares the different ways paths to resources are constructed
                within an app.</p>
            <p>The procedure described here was tested under eXist-db 4.4 and 4.5. This tutorial
                concentrates only on app development, and it is intended for users who already have
                a basic familiarity with XQuery and with the use of eXist-db as an XML database.
                Those who lack that familiarity will need to begin with the online eXist
                documentation and Siegel and Retter before proceeding to app development. In keeping
                with the recommmendations in Siegel and Retter, p. 40, we observe the following
                terminology:</p>
            <ol>
                <li><dfn>collection</dfn>: Comparable to a <dfn>directory</dfn> in the filesystem or
                    a <dfn>folder</dfn> in a GUI. Collections are hierarchical, so a collection may
                    contain <dfn>subcollections</dfn>.</li>
                <li><dfn>resource</dfn>: Comparable to a <dfn>file</dfn> in the filesystem. What is
                    a <dfn>filename</dfn> in the filesystem is a <dfn>resource name</dfn> in
                    eXist-db, a <dfn>filename extension</dfn> is a <dfn>resource name
                        extension</dfn>, and a <dfn>file type</dfn> is a <dfn>resource type</dfn>.
                    Resources may be XML, XQuery, or anything else.</li>
                <li><dfn>document</dfn>: An XML resource. Because XQuery may be used to create XML,
                    in the context of XInclude and other inclusions we may refer metonymically to
                    XQuery resources that generate XML as the <dfn>master document</dfn> and the
                        <dfn>included document</dfn>, even though either may be an XQuery script
                    that evaluates to an XML document, and not an actual XML document.</li>
                <li><dfn>script</dfn>: An XQuery resource.</li>
            </ol>
            <p>Because we sometimes upload files from the filesystem into eXist-db, where they
                become resources, we will also use filesystem-based terms as appropriate.</p>
        </section>
        <section id="skeleton">
            <h2>Create a new app skeleton</h2>
            <p>Start by using the app creation wizard inside eXide to create a skeleton for your new
                app.</p>
            <ol>
                <li>Inside eXide, choose Application → New application and authenticate as userid
                        <q>admin</q> or another user who is a member of the <code>dba</code>
                    (database administrator) group. This opens the app-creation wizard.</li>
                <li>Set Template to <q>Empty package</q>, Type of package to <q>Application</q>, and
                    Target collection to the bare name of your collection (that is, do not specify a
                    path). This assumes that you want to deploy the app into the standard location,
                    which is inside <i>/db/apps</i>; for example, a collection named
                        <q>repertorium</q> will be deployed to <i>/db/apps/repertorium</i> (and, for
                    that reason, do not use spaces or punctuation in the name of the Target
                    collection). Set the Name to a URI (it does not have to be an existing URL; it’s
                    an identifier, and not a location). Enter a Short name (which will be used as
                    the root of the filename for the eventual <i>.xar</i> archive, so don’t use any
                    spaces or punctuation here, either) and Title (which will be displayed in the
                    dashboard). Leave the Version as <q>0.1</q> (default) and the Status as
                        <q>Alpha</q> (default). Leave the Pre-install XQuery as
                        <q>pre-install.xql</q> and the Post-install XQuery as
                        <q>post-install.xql</q> (defaults). Click <q>Next</q>.</li>
                <li>Type your name into the Author field. You can add other authors later, if you
                    want; adding them with the Add button initially can be awkward. Enter an
                    optional description of the app under Description and a link to your principal
                    web site (you, not the app) under Website (these will be displayed in the
                    Package manager when the user clicks the button for more information). Click
                        <q>Next</q>.</li>
                <li>Create a userid for the Owner, create a password as the Password, and create a
                    groupid as the Group. Although it is possible to use existing credentials, we
                    recommend creating a unique user, group, and password just for the app, and
                    setting the name of the group to match that of the user. It is not necessary to
                    use an account with elevated privileges (e.g., <code>admin</code>, or any member
                    of the <code>dba</code> group). For the Repertorium project, we set the userid
                    and groupid both to <code>repertorium</code> and the password to an arbitrary
                    strong password. Leave Mode as <code>rw-rw-r--</code> (default). Click
                        <q>Done</q>.</li>
            </ol>
            <p>eXist-db should display an Open document dialog pointing to your collection, which
                should contain three documents: <i>build.xml</i>, <i>expath-pkg.xml</i>, and
                    <i>repo.xml</i>. Note that the wizard does not create any controller or index
                documents for your app, or pre-install or post-install scripts, so you’ll need to
                configure those separately, as described below.</p>
        </section>
        <section id="directories">
            <h2>Expand the skeleton</h2>
            <ol>
                <li>Inside the root collection of your app (e.g., <i>/db/apps/repertorium</i>)
                    create subcollections to hold different types of content. In the Repertorium
                    project we create the following subcollections: <ul>
                        <li><i>mss</i> These are our principal XML documents, which are manuscript
                            descriptions in TEI XML. Your app might use a more generic subcollection
                            name, such as <i>xml</i> or <i>data</i>.</li>
                        <li><i>aux</i> Auxiliary XML documents. In the Repertorium project, these
                            include a master bibliography and documents with master lists of article
                            names and genres.</li>
                        <li><i>modules</i> XQuery scripts</li>
                        <li><i>xslt</i> XSLT stylesheets, used to transform the results of queries
                            executed with XQuery</li>
                        <li><i>resources</i> These are auxiliary materials that may or may not be
                            XML. In the Repertorium project this holds five subcollections:<ul>
                                <li><i>pdf</i> PDF resources</li>
                                <li><i>js</i> JavaScript resources</li>
                                <li><i>css</i> CSS resources (with webfonts in a <i>fonts</i>
                                    subcollection under <i>css</i>)</li>
                                <li><i>includes</i> Static content that is inserted into XQuery
                                    output, similarly to server-side includes in a traditional
                                    Apache web app. In our example, this includes SVG</li>
                                <li><i>images</i> Static image resources (since we’ve chosen to put
                                    static SVG graphics under <i>includes</i>, our <i>images</i>
                                    collection contains just raster images)</li>
                            </ul></li>
                    </ul></li>
                <li>Optionally upload a file named <i>icon.png</i> into the root collection of your
                    app. If you include this, it will be displayed in the dashboard (at an
                    appropriate size); otherwise a generic eXist-db icon will be used.</li>
            </ol>
            <p>In most cases you will want to set the user and group for all resources to the userid
                and groupid you created when you configured the wizard, and if you create the
                resources above while you are authenticated as <code>admin</code> or another
                privileged user, the owner and group of the new resources will be set to values for
                that privileged user. You can reset the values now or defer that operation until the
                end, after you’ve created all of your content (see <a href="#generate">Generate your
                    app</a>, below).</p>
        </section>
        <section id="content">
            <h2>Add XML content and non-XML resources</h2>
            <ol>
                <li>Upload or create some XML documents (in this examples, in the <i>mss</i> and
                        <i>aux</i> subcollections).</li>
                <li>Upload or create content for the subcollections under <i>resources</i>, e.g.,
                    PDF, JavaScript, CSS, images, and boilerplate XML snippets.</li>
            </ol>
        </section>
        <section id="indexing">
            <h2>Add support for indexing</h2>
            <p>The skeleton does not contain either index documents or the code needed to deploy
                those into the correct location when the app is installed. We fix that by creating
                our own <i>pre-install.xql</i> script.</p>
            <ol>
                <li>Create a script called <i>pre-install.xql</i> with the following content and
                    upload or install it into the root collection of your app:
                    <pre>xquery version "3.0";

import module namespace xdb="http://exist-db.org/xquery/xmldb";

(: The following external variables are set by the repo:deploy function :)

(: file path pointing to the exist installation directory :)
declare variable $home external;
(: path to the directory containing the unpacked .xar package :)
declare variable $dir external;
(: the target collection into which the app is deployed :)
declare variable $target external;

declare function local:mkcol-recursive($collection, $components) {
    if (exists($components)) then
        let $newColl := concat($collection, "/", $components[1])
        return (
            xdb:create-collection($collection, $components[1]),
            local:mkcol-recursive($newColl, subsequence($components, 2))
        )
    else
        ()
};

(: Helper function to recursively create a collection hierarchy. :)
declare function local:mkcol($collection, $path) {
    local:mkcol-recursive($collection, tokenize($path, "/"))
};

(: store the collection configuration :)
local:mkcol("/db/system/config", $target),
xdb:store-files-from-pattern(concat("/db/system/config", $target), $dir, "*.xconf")</pre>
                    This instructs eXist-db to copy a <i>collection.xconf</i> (index) document (or
                    any document ending in <i>.xconf</i>) from the app root collection into the
                    appropriate location upon deployment. If you have index documents in
                    subcollections, you need to use an alternative form of the
                        <code>xdb:store-files-from-pattern()</code> function, one that looks into
                    subcollections, such as the following, where  <code>**/collection.xconf</code>
                    matches documents in any directory below the current one, and copies them at the
                    correct corresponding level under
                    <i>/db/config/system/db/</i>:<pre> xdb:store-files-from-pattern(
    concat(
        "/db/system/config", 
        $target
    ), 
    $dir, 
    "**/collection.xconf", 
    "application/xml", 
    true()
)</pre></li>
                <li>Create <i>collection.xconf</i> documents inside any subcollections that you wish
                    to index individually. Note that index documents must have the resource
                    extension <i>.xconf</i> (we recommend using the traditional document name
                        <i>collection.xconf</i>) and must be created inside the regular app
                    hierarchy, even though that is not where eXist-db normally looks for them in
                    order to build indexes. If you edit index documents during development, you’ll
                    need to keep the copy inside the app hierarchy, which is needed for deployment,
                    in sync with the one that eXist-db actually uses, under
                        <i>/db/config/system/db/apps/</i>. You can read more about configuring
                    indexes at <a href="http://exist-db.org/exist/apps/doc/indexing"
                        >http://exist-db.org/exist/apps/doc/indexing</a> or in Chapter 11, <q>Basic
                        indexing</q> and Chapter 12, <q>Text indexing and lookup</q> of Siegel and
                    Retter, pp. 271–302.</li>
            </ol>
            <p>eXist-db automatically indexes new XML documents as they are uploaded into the
                database, and eXide prompts you to reindex the collection whenever you edit an index
                document in place. But eXist-db does not automatically run the indexing procedure
                when you upload a new <i>collection.xconf</i> index. This means that if you upload
                    <i>collection.xconf</i> files during development, you need to reindex the
                collection explicitly.</p>
        </section>
        <section id="xquery">
            <h2>Create some XQuery scripts</h2>
            <section id="xquery_preliminaries">
                <h3>XQuery preliminaries in the context of eXist-db apps</h3>
                <p>Create XQuery scripts inside the <i>modules</i> subcollection. We observe the
                    recommendation in Siegel and Retter, p. xiv and use the filename extension
                        <i>.xql </i>for all <dfn>main modules</dfn>, that is, XQuery scripts that
                    are meant to be called and executed directly. Where we use XQuery library
                    modules, which are not meant to be executed, and which contain only functions
                    that are meant to be imported into main modules or other libraries, we use the
                    filename extension <i>.xqm</i>. Our projects do not use any other filename
                    extension for XQuery files.</p>
                <p>The <i>.xql</i> files inside <i>modules</i> will be responsible for creating the
                    content that will eventually be shown to users, some customized in response to
                    user input (e.g., queries that act on information supplied by the user in web
                    forms) and some in a relatively static way (that is, without customization in
                    response to user input). We use XQuery to retrieve content for inclusion in our
                    output, and we then rely on XSLT to transform content into HTML before
                    rendering. The transformation step is not strictly necessary for content that is
                    created initially entirely as HTML, and it would be more efficient to invoke an
                    XSLT transformation only when it is actually required, but the overhead is
                    slight, and it ultimately proved simplest, at least initially, to pass all
                    content through an XSLT transformation before returning it, even though that
                    transformation will be vacuous in the case of content that is already HTML.</p>
                <p class="note">Some developers avoid XSLT entirely, preferring to transform content
                    by using the XQuery <code>typeswitch()</code> function to simulate XSLT template
                    processing. In this tutorial, as in our actual projects, we use the XSLT
                    approach.</p>All HTML output from our projects is HTML 5.0 with XML syntax. We
                therefore use the HTML namespace, we specify a DOCTYPE declaration, and we set the
                eXist-db output <code>method</code> to <q>xml</q>, the <code>media-type</code> to
                    <q>application/xhtml+xml</q>, and, to avoid introducing unwanted whitespace
                artifacts, <code>indent</code> to <q>no</q>. We include an XML declaration in HTML
                to be returned, but we set <code>omit-xml-declaration</code> to <q>yes</q> when we
                generate XML that will be included into a larger context before being transformed
                and returned to the user.</section>
            <section id="xquery_main">
                <h3>Create a main page</h3>
                <p>Create a main page, called <i>index.xql</i>, inside the <i>modules</i>
                    subcollection. We will learn later how to make it the default (when the user
                    does not specify a page), how to simplify the URL (so that, for example, you
                    don’t have to specify <i>modules</i>, or even <i>index.xql</i>, as part of the
                    address), how to incorporate CSS and JavaScript, what links to other pages in
                    the app should look like, and how to include boilerplate content (e.g., a
                    consistent, page-independent header or menu). The first, simplest version of our
                    sample main page looks as follows:</p>
                <pre><![CDATA[xquery version "3.1";
declare default function namespace "http://www.w3.org/2005/xpath-functions";
declare default element namespace "http://www.w3.org/1999/xhtml";
declare namespace output = "http://www.w3.org/2010/xslt-xquery-serialization";
declare option output:method "xml";
declare option output:media-type "application/xhtml+xml";
declare option output:omit-xml-declaration "no";
declare option output:indent "no";
declare option output:doctype-system "about:legacy-compat";
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>My awesome eXist-db app</title>
    </head>
    <body>
        <h1>My awesome eXist-db app</h1>
        <p>Content will go here</p>
    </body>
</html>]]></pre>
            </section>
            <section id="xquery_css">
                <h3>Add CSS and JavaScript to the main page</h3>
                <p>CSS and JavaScript are incorporated into a page the same way they are with
                    traditional HTML, using <code>&lt;link&gt;</code> for CSS and
                        <code>&lt;script&gt;</code> for JavaScript. Links are relative to the page
                    being processed, so if we create <i>style.css</i> in the <i>resources/css</i>
                    collection and JavaScript in the <i>resources/js</i> collection, we can link to
                    them by modifying <i>index.xql</i> as follows (new code added to the first
                    example, above, is highlighted):</p>
                <pre><![CDATA[xquery version "3.1";
declare default function namespace "http://www.w3.org/2005/xpath-functions";
declare default element namespace "http://www.w3.org/1999/xhtml";
declare namespace output = "http://www.w3.org/2010/xslt-xquery-serialization";
declare option output:method "xml";
declare option output:media-type "application/xhtml+xml";
declare option output:omit-xml-declaration "no";
declare option output:indent "no";
declare option output:doctype-system "about:legacy-compat";
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>My awesome eXist-db app</title>]]>
        <span class="pre-highlight"><![CDATA[<link rel="stylesheet" type="text/css" href="../resources/css/style.css"/>
        <script type="text/javascript" src="../resources/js/greet.js"></script>]]></span>
<![CDATA[    </head>
    <body>
        <h1>My awesome eXist-db app</h1>
        <p>Content will go here</p>
    </body>
</html>]]></pre>
                <p>Because our XQuery scripts are in our <i>modules</i> subcollection, these
                    relative paths climb up from there to the app root collection and then down to
                    where the CSS and JavaScript files are located. Because Best Practice in
                    eXist-db is to use absolute paths wherever possible, we’ll change the relative
                    paths to absolute paths below, once we have created a <i>controller.xql</i>
                    file.</p>
            </section>
            <section id="xquery_variables">
                <h3>Use variables to avoid repetition</h3>
                <p>The example above repeats the same text as the content of the
                        <code>&lt;title&gt;</code> element inside the <code>&lt;head&gt;</code> and
                    the <code>&lt;h1&gt;</code> at the beginning of the <code>&lt;body&gt;</code>.
                    Consistently with <a
                        href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself"><dfn>DRY</dfn>
                            (<q>Don’t Repeat Yourself</q>)</a>, we can avoid the repetition by
                    abstracting the text into a variable:</p>
                <pre>xquery version "3.1";
declare default function namespace "http://www.w3.org/2005/xpath-functions";
declare default element namespace "http://www.w3.org/1999/xhtml";
declare namespace output = "http://www.w3.org/2010/xslt-xquery-serialization";
declare option output:method "xml";
declare option output:media-type "application/xhtml+xml";
declare option output:omit-xml-declaration "no";
declare option output:indent "no";
declare option output:doctype-system "about:legacy-compat";
<span class="pre-highlight">declare variable $title as xs:string := "My awesome eXist-db app";</span>
<![CDATA[<html xmlns="http://www.w3.org/1999/xhtml">
    <head>]]>
        <span class="pre-highlight"><![CDATA[<title>{$title}</title>]]></span>
        <![CDATA[<link rel="stylesheet" type="text/css" href="../resources/css/style.css"/>
        <script type="text/javascript" src="../resources/js/greet.js"></script>
    </head>
    <body>]]>
        <span class="pre-highlight"><![CDATA[<h1>{$title}</h1>]]></span>
        <![CDATA[<p>Content will go here</p>
    </body>
</html>]]></pre>
            </section>
            <section id="xquery_paths">
                <h3>Construct paths within XQuery scripts</h3>
                <p>One advantage of the eXist-db app architecture is its flexibility: all components
                    of the app are contained in a single archive file that can be hot-installed into
                    any running instance of eXist-db. More specifically, if the app is constructed
                    with appropriate attention to absolute and relative paths, it is not dependent
                    on a specific server name, server port, or location within the eXist-db
                    database. This means, though, that paths to resources within the database must
                    be constructed in a way that avoids unnecessary assumptions.</p>
                <p>As an example, suppose our collection hierarchy, as described <a
                        href="#directories">above</a>, is that <i>controller.xql</i> is in the root
                    collection for the app (<i>/db/apps/repertorium</i> in our case), our XML data
                    files are in a subcollection called <i>mss</i>, and our XQuery scripts are in a
                    subcollection called <i>modules</i>. We describe <a href="#controller">below</a>
                    how the controller rewrites a URL to point to a resource inside <i>modules</i>,
                    and also how to construct paths to XIncluded content (inside an <i>includes</i>
                    subcollection in our example, and processed by eXist-db) and to CSS and
                    JavaScript (inside <i>css</i> and <i>js</i> subcollections of a <i>resources</i>
                    subcollection, and processed by jetty, the web server that hosts the eXist-db
                    application). If our script needs to refer to, say, the documents inside
                        <i>mss</i>, we can construct a variable that points to them with
                        <code>collection(concat($exist:root, $exist:controller, "/mss'))</code>. The
                    meanings of those variables are discussed below, but by way of introduction, in
                    a standard eXist-db installation, this path is interpreted as
                        <code>collection("xmldb:exist:///db/apps/repertorium/mss")</code>. But
                    because we have used variables supplied by eXist-db to construct the path,
                    instead of specifying it as a string literal, the path will also be correct no
                    matter what the name of the root collection is, and no matter where it we
                    install our apps in our eXist-db instance, and it makes no assumptions about
                    either the server name or the port.</p>
            </section>
            <section id="xquery_beyond">
                <h3>Beyond static HTML</h3>
                <p>The preceding example uses XQuery to create static HTML, and it has the following
                    limitations, which we will address when we discuss <a href="#xinclude"
                        >XInclude</a> and <a href="#controller"><i>controller.xql</i></a> in the
                    following sections:</p>
                <ul>
                    <li>The XQuery has not been designed to respond to user input. That is, there is
                        no way to call the same XQuery with different parameters in order to receive
                        different, customized output.</li>
                    <li>The page contains boilerplate that we will probably want to include in many
                        other pages. At the moment this might involve links to site-standard CSS or
                        JavaScript, but it could also involve HTML content snippets, such as
                        headers, footers, and menus.</li>
                    <li>The URL that retrieves this page is
                            <code>http://localhost:8080/exist/db/apps/repertorium/modules/index.xql</code>
                        (where <i>repertorium</i> is the name of the app). We would prefer a less
                        cluttered and less verbose URL.</li>
                    <li>Insofar as this is intended to be our default page, we would like the user
                        to be able to load it by navigating to the root of the app, e.g., without
                        specifying the <i>index.xql</i> filename.</li>
                </ul>
            </section>
        </section>
        <section id="xinclude">
            <h2>Modularize with XInclude</h2>
            <section id="xinclude_preliminaries">
                <h3>XInclude preliminaries in the context of eXist-db apps</h3>
                <p>By default eXist-db supports the inclusion of XML snippets inside another XML
                    document with <a href="https://www.w3.org/TR/xinclude-11/">XInclude</a>. For
                    more information about using XInclude inside eXist-db, see <a
                        href="https://exist-db.org/exist/apps/doc/xinclude"
                        >https://exist-db.org/exist/apps/doc/xinclude</a> and the <q>XInclude</q>
                    section of Chapter 10, <q>Other XML technologies</q>, in Siegel and Retter, pp.
                    243–45.</p>
                <p>The following details govern the use of XInclude within eXist-db:</p>
                <ul>
                    <li>Includes are expressed with an empty <code>&lt;xi:include&gt;</code>
                        element, where the prefix <code>xi:</code> is bound to the namespace
                            <code>http://www.w3.org/ 2001/XInclude</code>, which must be
                        declared.</li>
                    <li>The document to be included is specified with an <code>@href</code>
                        attribute on the <code>&lt;xi:include></code> element. The value of the
                            <code>@href</code> attribute must be an absolute (not relative) path,
                        such as
                            <code>http://localhost:8080/exist/rest/db/apps/repertorium/includes/header.xql</code>,
                            <code>xmldb:exist:///db/apps/repertorium/includes/header.xql</code>, or
                            <code>/exist/rest/db/apps/repertorium/includes/header.xql</code>. We are
                        actually going to construct, rather than specify, the path, which depends on
                        our having configured <i>controller.xql</i>, so we’ll discuss it separately
                        once we’ve taken care of that configuration.</li>
                    <li>The target of the <code>@href</code> attribute must be well-formed XML.</li>
                    <li>It is possible to include either an entire XML document or a part of one.
                        The entire document is the default; parts may be specified by adding an
                            <code>@xpointer</code> attribute to the <code>&lt;xi:include&gt;</code>
                        element in one of two ways:<ul>
                            <li>An <code>@xpointer</code> attribute may point to an
                                    <code>@xml:id</code> attribute in the included document. For
                                example, <code>&lt;xi:include
                                    href="xmldb:exist:///db/apps/repertorium/includes/filename.xml
                                    xpointer="stuff"/&gt;</code> will include the element inside
                                    <i>filename.xml</i> that has an <code>@xml:id</code> value of
                                    <q>stuff</q>.</li>
                            <li>Alternatively the value of the <code>@xpointer</code> attribute may
                                be an XPath expression wrapped in <code>xpointer()</code>, which is
                                traversed within the target document. For example,
                                    <code>&lt;xi:include
                                    href="xmldb:exist:///db/apps/repertorium/includes/filename.xml
                                    xpointer="xpointer(//l[1])"/&gt;</code> returns the first
                                    <code>&lt;l&gt;</code> element in the target document.</li>
                        </ul></li>
                    <li>One powerful feature of XInclude within eXist-db is that if the value of the
                            <code>@href</code> attribute is an XQuery script, the XQuery will be
                        executed and its output will be included. Scripts specified in this way
                        automatically have access to the following information:<ul>
                            <li><code>$xinclude:current-doc</code>, when used inside the included
                                resource, points to the bare name of the master document. This makes
                                it possible for the included document to adjust its output according
                                to where it is being included. We use this in the Repertorium
                                project to customize the boilerplate header to include or exclude
                                particular buttons depending on the master document (discussed below
                                    <strong>TODO</strong>). There is also an
                                    <code>$xinclude:current-collection</code> variable that points
                                to the collection that contains the master document.</li>
                            <li>It is possible to pass parameters to the included document as part
                                of a URL query string, e.g., <code>&lt;xi:include
                                    href="xmldb:exist:///db/apps/repertorium/includes/filename.xql?title=Hi"/></code>.
                                The included document must declare the parameter, along the lines of
                                    <code>declare variable $title external;</code>. If the parameter
                                value contains spaces or puncutation, it must be encoded as if it
                                were a URI, e.g., <code>&lt;xi:include
                                    href="xmldb:exist:///db/apps/repertorium/includes/filename.xql?title={encode-for-uri('Hi,
                                    Mom!')}"/&gt;</code>. We use this in the Repertorium project to
                                pass a customized, page-specific value for the
                                    <code>&lt;title></code> element of what would otherwise be a
                                boilerplate HTML <code>&lt;head></code>.</li>
                            <li>If the value of the <code>@href</code> attribute is an XQuery
                                script, and not an XML document, the <code>@xpointer</code>
                                attribute is ignored. That is, the <code>@xpointer</code> attribute
                                is meaningful only when the the target of the <code>@href</code>
                                attribute is an XML document, and not an XQuery script.</li>
                        </ul></li>
                </ul>
            </section>
            <section id="xinclude_header">
                <h3>Managing boilerplate information with XInclude</h3>
                <p>Since all of our app documents will use at least some of the same CSS and
                    JavaScript, we can move the <code>&lt;head&gt;</code> element, which contains
                    the <code>&lt;link&gt;</code> and <code>&lt;script&gt;</code> elements, into a
                    separate included resource. Since the title will vary with different master
                    documents, we can pass it as a parameter. Our <i>index.xql</i> now looks like
                    the following:</p>
                <pre><![CDATA[xquery version "3.1";
declare default function namespace "http://www.w3.org/2005/xpath-functions";
declare default element namespace "http://www.w3.org/1999/xhtml";
declare namespace xi="http://www.w3.org/2001/XInclude";
declare namespace output = "http://www.w3.org/2010/xslt-xquery-serialization";
declare option output:method "xml";
declare option output:media-type "application/xhtml+xml";
declare option output:omit-xml-declaration "no";
declare option output:indent "no";
declare option output:doctype-system "about:legacy-compat";
declare variable $title as xs:string := "My awesome eXist-db app";
<html xmlns="http://www.w3.org/1999/xhtml">]]>
    <span class="pre-highlight"><![CDATA[<xi:include 
        href="xmldb:exist:///db/apps/repertorium/includes/header.xql?title={encode-for-uri($title)}"/>]]></span>
    <![CDATA[<body>
        <h1>{$title}</h1>
        <p>Content will go here</p>
    </body>
</html>]]></pre>
                <p>and the new included resource looks like:</p>
                <pre><![CDATA[xquery version "3.1";
declare variable $title external;
<head xmlns="http://www.w3.org/1999/xhtml">
    <title>{$title}</title>
    <link rel="stylesheet" type="text/css" href="../resources/css/style.css"/>
    <script type="text/javascript" src="../resources/js/greet.js"></script>
</head>]]></pre>
                <p>The content of the <code>&lt;head&gt;</code> element is the same, but it is now
                    located inside the included <i>header.xql</i> script, instead of directly inside
                        <i>index.xql</i>.</p>
                <p>This point of this strategy is that we assume that all files will have
                    essentially the same <code>&lt;head&gt;</code> element, except for the content
                    of the <code>&lt;title&gt;</code> element. If we put the
                        <code>&lt;head&gt;</code> into an included resource, should we later need to
                    modify it, we can modify it in just one place and the changes will be reflected
                    in all pages that include it. We deal with the difference in titles by passing
                    the value into the included resource as a parameter, where it is interpreted
                    before rendering. We use the <code>encode-for-uri()</code> function, introduced
                    above, because titles may contain spaces or punctuation, which cannot otherwise
                    be passed from the master XQuery to the included one. Below we’ll modify the
                    path to the included resource to simplify it by removing the dependency on
                    installation inside <i>/db/apps</i>. We’ll also replace the relative paths to
                    CSS and JavaScript resources with absolute paths that adapt to the name and
                    installation location of the app. Finally, we’ll also customize the header in
                    other ways, such as by using information about the including page to determine
                    which interface buttons are rendered.<strong>(TODO)</strong></p>
            </section>
        </section>
        <section id="controller">
            <h2>Configure <i>controller.xql</i></h2>
            <section id="controller_preliminaries">
                <h3>What to expect from <i>controller.xql</i></h3>
                <p>If an app contains a <i>controller.xql</i> script in its root collection, eXist
                    automatically passes all HTTP requests to the controller. The controller can
                    rewrite the request, by, for example, routing it to a specific XQuery script, or
                    it can pass it along unchanged to be handled normally. This tutorial does not
                    include a beginner’s introduction to controller configuration, and <strong>new
                        developers must pause at this point and read <a
                            href="http://exist-db.org/exist/apps/doc/urlrewrite"
                            >http://exist-db.org/exist/apps/doc/urlrewrite</a> and Chapter 9,
                            <q>Building applications</q>, of Siegel and Retter pp. 191–235</strong>.
                    Understanding the examples below requires a basic familiarity with query
                    handling and the eXist-db <i>controller.xql</i> file, as provided at these
                    links. We also recommend, as an example, Joe Wicentowski’s <cite><a
                            href="https://github.com/joewiz/punch">Punch</a></cite>, a tutorial
                    project that uses a clearly commented <i>controller.xql</i> to illustrate query
                    rewriting within an eXist-db app. Our project will contain exactly one
                        <i>controller.xql</i> resource, which will be located inside the app root
                    collection.</p>
            </section>
            <section id="controller_skeleton">
                <h3>Create a skeletal <i>controller.xql</i> skeleton</h3>
                <p>Start by creating a skeletal <i>controller.xql</i> script in the root collection
                    of your application with the following contents (copied, with minor
                    modifications, from Siegel and Retter, p. 196):</p>
                <pre>xquery version "3.1" encoding "UTF-8";

(: External variables available to the controller: 
$exist:path
    The part of the URL after the part that led to the controller. For example:
    /a/b/c.xq
$exist:resource
    The part of the URL after the last / character, usually pointing to a 
    resource. For example: c.xq
$exist:controller
    The part of the URL leading from the prefix (typically /apps) to the controller 
    script. For example, the name of the root collection of your app, for example:
    /repertorium
$exist:root
    The path to where the app is installed, typically xmldb:exist:///db/apps.
:)
declare variable $exist:path external;
declare variable $exist:resource external;
declare variable $exist:controller external;
declare variable $exist:root external;

(: Other variables :)
declare variable $home-page-url := "index";

(: Function to get the extension of a filename: :)
declare function local:get-extension($filename as xs:string) as xs:string {
    let $name := replace($filename, ".*[/\\]([^/\\]+)$", "$1")
    return
        if (contains($name, "."))
        then
            replace($name, ".*\.([^\.]+)$", "$1")
        else
            ""
};

(: If there is no resource specified, go to the home page.
This is a redirect, forcing the browser to perform a redirect. So this request
will pass through the controller again... :)
if ($exist:resource eq "") then
    &lt;dispatch xmlns="http://exist.sourceforge.net/NS/exist">
        &lt;redirect url="{$home-page-url}"/>
    &lt;/dispatch>
    
(: Check if there is no extension. If not, assume it is an XQuery script and forward
to the actual XQuery script by inserting the "modules/" step to the subcollection and
adding the ".xql" extension. Because we use forward here, the browser will not be 
informed of the change and the user will see a URL without the "modules/" step in the
path and without the ".xql" extension. :)
else
    if (local:get-extension($exist:resource) eq "") then
        &lt;dispatch xmlns="http://exist.sourceforge.net/NS/exist">
            &lt;forward url="{concat(
                $exist:controller, 
                substring-before($exist:path, $exist:resource), 
                "modules/", 
                $exist:resource, ".xql"
            )}"/>
        &lt;/dispatch>
        (: Anything else, pass through: :)
    else
        &lt;ignore xmlns="http://exist.sourceforge.net/NS/exist">
            &lt;cache-control cache="yes"/>
        &lt;/ignore></pre>
                <p>If you navigate to <code>http://localhost:8080/exist/db/apps/repertorium/</code>
                    (replace <q>repertorium</q> with the name of your app), you should see the
                    output of executing the <i>index.xql</i> script that is in your <i>modules</i>
                    subcollection, and the URL will change to
                        <code>http://localhost:8080/exist/db/apps/repertorium/index</code>. But:</p>
                <ul>
                    <li>Your CSS and JavaScript links don’t work; you get the HTML, but not the
                        styling or JavaScript functionality.</li>
                    <li>You can also retrieve the main page by asking for
                            <code>http://localhost:8080/exist/db/apps/repertorium/index</code>.</li>
                    <li>Asking for
                            <code>http://localhost:8080/exist/db/apps/repertorium/modules/index.xql</code>,
                        which is where your XQuery actually resides, works, and includes the CSS and
                        JavaScript that don’t work (yet) with the rewriting.</li>
                    <li>Asking for
                            <code>http://localhost:8080/exist/db/apps/repertorium/index.xql</code>
                        (that is, omitting the <code>modules/</code> step but adding the
                            <code>.xql</code> extension), raises an error.</li>
                    <li>You need the trailing slash. This is the one limitation you cannot control
                        from within your app because without the slash, the URL never reaches your
                        controller.</li>
                </ul>
                <p>Except for the last point, we need to fix the controller to ensure that CSS and
                    JavaScript are processed properly, and that behavior is consistent with
                    reasonable user expectations. But first we need to understand how it works, and
                    that understanding starts with eXist-db controller variables and the
                        <code>request:</code> module.</p>
            </section>
            <section id="controller_variables">
                <h3>System variables and <i>controller.xql</i></h3>
                <p>eXist-db automatically makes the following five system variables available within
                        <i>controller.xql</i>:</p>
                <ul>
                    <li><code>$exist:root</code> The part of the database URL the precedes the name
                        of the collection that contains the controller. In a standard installation
                        this location is <code>xmldb:exist:///db/apps</code>.</li>
                    <li><code>$exist:prefix</code> The part of the URL that precedes the controller.
                        The default value is <code>/apps</code>.</li>
                    <li><code>$exist:controller</code> The part of the URL leading from the prefix
                        (typically <code>/apps</code>) into the collection that contains the
                        controller script, which in this case (and typically) is the root collection
                        of your app, for example: <code>/repertorium</code>.</li>
                    <li><code>$exist:path</code> The part of the URL after the part that led to the
                        controller. For example: <code>/index</code>.</li>
                    <li><code>$exist:resource</code> The part of the URL after the last
                            <code>/</code> character, which typically resolves to a resource after
                        query rewriting. For example: <code>index</code> (which in the Repertorium
                        resolves to <code>/modules/index.xql</code>). This value is null if the URL
                        ends in a slash, although the controller will still resolve it to a real
                        resource.</li>
                </ul>
                <p>The relationships among these variables and between them and parts of the URL are
                    illustrated in the following table. Note that some variables contain other
                    variables within themselves:</p>
                <table>
                    <tr>
                        <th>Variable</th>
                        <th colspan="2"><code>$exist:root</code></th>
                        <th rowspan="2"><code>$exist:controller</code></th>
                        <th colspan="2"><code>$exist:path</code></th>
                    </tr>
                    <tr>
                        <th>Variable</th>
                        <th>[none]</th>
                        <th><code>$exist:prefix</code></th>
                        <th>[none]</th>
                        <th><code>$exist:resource</code></th>
                    </tr>
                    <tr>
                        <th>Value</th>
                        <td><code>xmldb:exist:///db</code></td>
                        <td><code>/apps</code></td>
                        <td><code>/repertorium</code></td>
                        <td><code>/</code></td>
                        <td><code>index</code></td>
                    </tr>
                </table>
                <p><code>$exist:prefix</code>, <code>$exist:controller</code>, and
                        <code>$exist:path</code> always begin with a slash;
                        <code>$exist:resource</code> never does. None of these variables ever ends
                    in a slash, with the exception of <code>$exist:path</code> when no resource is
                    specified. This is important because we’re going to stitch some of these pieces
                    together to form a new path, and we need to understand where we have to add
                    slashes and where they are already present.</p>
            </section>
            <section id="controller_request">
                <h3>The <code>request:</code> module and <i>controller.xql</i></h3>
                <p>In addition to the preceding five variables that are automatically available to
                    the controller, the eXist-db <code>request:</code> module provides two functions
                    that we use for query rewriting:</p>
                <ul>
                    <li><code>request:get-uri()</code> Returns the URL before query rewriting, for
                        example, <code>/exist/apps/repertorium/index</code>.</li>
                    <li><code>request:get-context-path()</code> Returns the part of the URL that
                        precedes the prefix, typically <code>/exist</code>.</li>
                </ul>
                <p>We can use the variables described in the preceding section plus the functions
                    described here to construct a path to any location in our app. For example, a
                    path to <i>/exist/apps/repertorium/includes/header.xql</i> could be constructed
                    by concatenating variable and function values as follows:</p>
                <table>
                    <tr>
                        <th>Function or variable</th>
                        <th><code>request:get-context-path()</code></th>
                        <th><code>$exist:prefix</code></th>
                        <th><code>$exist:controller</code></th>
                        <th>[none]</th>
                    </tr>
                    <tr>
                        <th>Value</th>
                        <td><code>/exist</code></td>
                        <td><code>/apps</code></td>
                        <td><code>/repertorium</code></td>
                        <td><code>/includes/header.xql</code></td>
                    </tr>
                </table>
            </section>
            <section id="controller_example" style="display:flex; flex-direction: column;">
                <h3>Examining controller variables and <code>request:</code> function values</h3>
                <div>
                    <img src="exist-variables.png" alt="[Screen shot of eXist variables]"
                        style="float: right; max-width: 50%; min-width: 500px" />
                    <p>As described in the two immediately preceding sections, <i>controller.xql</i>
                        makes several system variables and other information available both for its
                        own use and to be passed to other XQuery scripts as parameters during query
                        rewriting. We use this facility in the Repertorium project to make it
                        possible for included resources that themselves have to point to other
                        resources (e.g., an XIncluded HTML <code>&lt;head&gt;</code> that links to
                        CSS and JavaScript resources) to construct absolute paths within the
                        database. Note that because links to CSS and JavaScript are resolved by the
                        browser, which doesn’t know about <code>xmldb:exist:///</code> URLs, those
                        pointers must instead rely on URLs that concatenate the value of
                            <code>request:get-context-path()</code> (typically <code>/exist</code>),
                        the value of <code>$exist:prefix</code> (typically <code>/apps</code>) and
                        the value of <code>$exist:controller</code> (typically the root collection
                        of the app, with a leading slash, e.g., <code>/repertorium</code>); we save
                        the result of this concatenation in a constructed variable that we call
                            <code>$fqcontroller</code>. The sample output on the right displays the
                        available variables and their values in the context of the Repertorium
                        project, which we have installed into
                            <code>xmldb:exist:///db/apps/repertorium</code>. We find this type of
                        table of controller variables a useful reference during development. The
                        XQuery that creates the table is in <a href="#variable_output">Appendix A:
                            Controller variables and <code>request:</code> functions</a>.</p>
                    <p>Using the variables in question in an app requires three steps:</p>
                    <ol>
                        <li>Use them to construct a rewritten path to the resource that should be
                            returned or otherwise processed;</li>
                        <li>Forward them from <i>controller.xql</i> as parameters to XQuery scripts
                            during query rewriting;</li>
                        <li>Retrieve and use them in those scripts.</li>
                    </ol>
                    <p>The last step may also entail forwarding them to included resources so that
                        they can be used to point to additional linked or included information. One
                        such use case, mentioned above, is that an HTML page may XInclude a
                            <code>&lt;head&gt;</code> element, which might itself need to point to
                        CSS or JavaScript resources.</p>
                    <p>The five variables that begin with <code>$exist:</code> in the table above
                        are automatically available within <i>controller.xql</i> (we declare them as
                            <code>external</code>), and we create the <code>$uri</code> and
                            <code>$context</code> variables within the controller by calling the
                        appropriate functions in the <code>request:</code> namespace (this strategy
                        is based on <a href="https://github.com/joewiz/punch"
                            >https://github.com/joewiz/punch</a>). The relevant parts of
                            <i>controller.xql</i> are:</p>
                </div>
                <pre>declare variable $exist:root external;
declare variable $exist:prefix external;
declare variable $exist:controller external;
declare variable $exist:path external;
declare variable $exist:resource external;

declare variable $uri as xs:anyURI := request:get-uri();
declare variable $context as xs:string := request:get-context-path();</pre>
                <p>We then forward those seven variables during rewriting with the following rewrite
                    rule inside <i>controller.xql</i> (which is based on a script at <a
                        href="https://github.com/eXist-book/book-code"
                        >https://github.com/eXist-book/book-code</a>). Our forwarding rule uses the
                        <code>&lt;add-parameter&gt;</code> element to forward all of our controller
                    variables to any receiving script (we discuss the forwarding process, including
                    construction of the forwarding <code>@url</code> value, below):</p>
                <pre><![CDATA[if (local:get-extension($exist:resource) eq "") then
    <dispatch xmlns="http://exist.sourceforge.net/NS/exist">
        <forward url="{concat(
            $exist:controller, 
            substring-before($exist:path, $exist:resource), 
            "modules/", 
            $exist:resource, 
            ".xql"
        )}">]]>
            <span class="pre-highlight"><![CDATA[<add-parameter name="exist:root" value="{$exist:root}"/>
            <add-parameter name="exist:prefix" value="{$exist:prefix}"/>
            <add-parameter name="exist:controller" value="{$exist:controller}"/>
            <add-parameter name="exist:path" value="{$exist:path}"/>
            <add-parameter name="exist:resource" value="{$exist:resource}"/>
            <add-parameter name="uri" value="{$uri}"/>
            <add-parameter name="context" value="{$context}"/>]]></span>
        <![CDATA[</forward>
    </dispatch>]]></pre>
            </section>
            <section id="controller_skeleton_discussion">
                <h3>How <i>controller.xql</i> rewrites a query URL</h3>
                <p>Understanding the part of the controller that deals with XQuery files is the key
                    to understanding how XQuery rewriting is implemented in an app, so let’s look at
                    the most important part of it closely:</p>
                <pre><span class="pre-highlight">if (local:get-extension($exist:resource) eq "")</span> then
    &lt;dispatch xmlns="http://exist.sourceforge.net/NS/exist">
        &lt;forward url="{concat(
            <span class="pre-highlight">$exist:controller, 
            substring-before($exist:path, $exist:resource), 
            "modules/", 
            $exist:resource, 
            ".xql"</span>
        )}"/>
    &lt;/dispatch></pre>
                <p>The <code>local:get-extension($exist:resource)</code> function retrieves the
                    extension from <code>$exist:resource</code>, which, as noted above, is the part
                    of the original URL after the final slash. If <code>$exist:resource</code> is
                    not null (that is, if the original URL does not end in a slash, about which see
                    below), it may or may not have an extension. For example, <code>index.xql</code>
                    has the extension <i>.xql</i>; <code>index</code> does not have an extension. If
                    there is no extension, the <code>local:get-extension()</code> function will
                    return the empty string; otherwise it will return the extension without the
                    leading dot (for example, <code>xql</code>).</p>
                <p>The <code>if</code> clause tests whether the original query has no extension
                    (such as when the user asks for
                        <code>http://localhost:8080/exist/db/apps/repertorium/index</code>, rather
                    than something ending in <code>index.xql</code>). We’ve decided that the
                    convention in our app will be that resources without extensions are XQuery
                    scripts, so we want the controller to forward the call to a modified URL, and
                    the modifications involve 1) looking in the <i>modules</i> subcollection and 2)
                    adding an <i>.xql</i> extension. The modified URL will be an absolute path,
                    which is resolved starting from the prefix, which in our case (and as a default)
                    means starting after <i>/exist/apps</i>. In the case of the Repertorium project,
                    we want the path to begin at <i>/repertorium</i>, that is, in the root
                    collection of the app. The script builts up that modified URL by concatenating
                    the following values, in order:</p>
                <ul>
                    <li><code>$exist:controller</code> This is the location of <i>controller.xql</i>
                        file, which is the root collection of the app, starting with a slash, e.g.,
                            <code>/repertorium</code>. Our aggregated rewritten URL is now just
                            <code>/repertorium</code>.</li>
                    <li><code>substring-before($exist:path, $exist:resource)</code>.
                            <code>$exist:path</code> is the path from the location of the controller
                        to the end of the URL (minus any query string), which in the case of
                            <code>http://localhost:8080/exist/db/apps/repertorium/index</code>, is
                        just <code>/index</code>. <code>$exist:resource</code> is the part after the
                        final slash, which in this case is just <code>index</code>. This means that
                        our <code>substring-before()</code> function returns just a slash. When we
                        append the slash to our aggregated path, it is now equal to
                            <code>/repertorium/</code>.</li>
                    <li><code>modules/</code> Since our XQuery lives in a <i>modules</i>
                        subcollection that we don’t want the user to have to specify in the URL, we
                        add it during query rewriting. The aggregated URL now looks like
                            <code>/repertorium/modules/</code>.</li>
                    <li><code>$exist:resource</code> As mentioned above, this variable is the part
                        of the original URL after the final slash, which in this case was
                            <code>index</code>. When we add it, our aggregated URL looks like
                            <code>/repertorium/modules/index</code>.</li>
                    <li><code>.xql</code> Since our XQuery resources have <i>.xql</i> extensions, we
                        add that at the end of the rewritten URL, finally yielding
                            <code>/repertorium/modules/index.xql</code>.</li>
                </ul>
                <p>Since that final result is the actual path to our main page, the XQuery is
                    processed and the output is loaded into the browser. Because we used
                        <code>&lt;forward&gt;</code> (instead of <code>&lt;redirect&gt;</code>), the
                    browser address bar continues to display the URL without the modifications, even
                    though the browser uses those modifications to find and load the file.</p>
            </section>
            <section id="controller_includes">
                <h3>Fixing links to includes</h3>
                <p>As a general rule of thumb, wherever possible paths in an app should be absolute
                    (not relative), should not assume that apps are always installed under
                        <i>/db/apps</i>, and should use database URLs (beginning with
                        <i>xmldb:exist:///</i>) rather than HTTP URLs (beginning with
                        <i>http://localhost:8080/exist</i>). Absolute database URLs that do not make
                    unnecessary assumptions about paths are the most robust with respect to query
                    rewriting and the possible physical relocation of resources. When we first
                    constructed our <i>index.xql</i> file when introducing XInclude (see <a
                        href="#xinclude_header">Managing boilerplate information with XInclude</a>),
                    the link from <i>index.xql</i> to <i>header.xql</i>, which contained the HTML
                        <code>&lt;head&gt;</code> element, read
                        <code>href="xmldb:exist:///db/apps/repertorium/includes/header.xql?title={encode-for-uri($title)}</code>,
                    which will break if the app is installed into a non-standard location.
                    Additionally, the links to CSS and JavaScript in <i>header.xql</i>, introduced
                    in the same section of this tutorial, used relative paths (e.g.,
                        <code>href="../resources/css/style.css"</code>), and those <em>did</em>
                    break as soon as we rewrote our query. The reason the links broke is that the
                    path is traversed from the original URL, without the <i>/modules</i> step, so
                    instead of climbing out of <i>modules</i> and then down into <i>resources</i>,
                    it climbs out of <i>repertorium</i> and then fails to find a <i>resources</i>
                    child collection for the next path step.</p>
                <p>To fix the broken or fragile links and make our code generally more robust we
                    needed to change both the <i>index.xql</i> master document and the
                        <i>header.xql</i> included document to use controller variables and
                        <code>request:</code> functions to construct absolute paths. We also needed
                    to change <i>controller.xql</i> to make those variables available to
                        <i>index.xql</i> and <i>header.xql</i>. In the example at <a
                        href="#controller_skeleton_discussion">How <i>controller.xql</i> rewrites a
                        query URL</a>, we used the variables to construct the rewritten URL, and in
                    the more complete controller example in <a href="#controller_example">Examining
                        controller variables and <code>request:</code> function values</a>, we used
                        <code>&lt;add-parameter&gt;</code> to forward the variables during rewriting
                    so that they can be reused when the script for the page is processed and
                    rendered. The forwarding instruction with the parameters looks like:</p>
                <pre><![CDATA[if (local:get-extension($exist:resource) eq "") then
    <dispatch xmlns="http://exist.sourceforge.net/NS/exist">
        <forward url="{concat(
            $exist:controller, 
            substring-before($exist:path, $exist:resource), 
            "modules/", 
            $exist:resource, 
            ".xql"
        )}">]]>
<span class="pre-highlight"><![CDATA[            <add-parameter name="exist:root" value="{$exist:root}"/>
            <add-parameter name="exist:prefix" value="{$exist:prefix}"/>
            <add-parameter name="exist:controller" value="{$exist:controller}"/>
            <add-parameter name="exist:path" value="{$exist:path}"/>
            <add-parameter name="exist:resource" value="{$exist:resource}"/>
            <add-parameter name="uri" value="{$uri}"/>
            <add-parameter name="context" value="{$context}"/>]]></span>
<![CDATA[        </forward>
    </dispatch>]]></pre>
                <p>If, for example, the original URL was
                        <code>http://localhost:8080/exist/db/apps/repertorium/index</code>, the
                    forwarding instruction rewrites the URl as
                        <code>xmldb:exist:///db/apps/repertorium/modules/index.xql</code>, and it
                    makes the seven parameters available from within that script.</p>
                <p>The values that are forwarded with <code>&lt;add-parameter&gt;</code> can be
                    retrieved by the target script with the <code>request:get-parameter()</code>
                    function. Those values can be used to construct a path to an XIncluded
                        <i>header.xql</i>, and the XInclude instruction can also pass the variables
                    into the <i>header.xql</i> script, so that they can be used there to construct
                    absolute paths to the CSS and JavaScript resources. Since we don’t need all of
                    the variables down the pipeline, we retrieve and forward only the ones we
                    actually use. The <i>index.xql</i> page might look like the following:</p>
                <pre>
xquery version "3.1";
declare default function namespace "http://www.w3.org/2005/xpath-functions";
declare default element namespace "http://www.w3.org/1999/xhtml";
declare namespace xi="http://www.w3.org/2001/XInclude";
declare namespace output = "http://www.w3.org/2010/xslt-xquery-serialization";
declare option output:method "xml";
declare option output:media-type "application/xhtml+xml";
declare option output:omit-xml-declaration "no";
declare option output:indent "no";
declare option output:doctype-system "about:legacy-compat";
<span class="pre-highlight">declare variable $title as xs:string := "Repertorium of Old Bulgarian Literature and Letters";
declare variable $exist:root as xs:string := request:get-parameter("exist:root", ());
declare variable $exist:prefix as xs:string := request:get-parameter("exist:prefix", ());
declare variable $exist:controller as xs:string := request:get-parameter("exist:controller", ());
declare variable $context as xs:string := request:get-parameter("context", ());
declare variable $fqcontroller as xs:string := concat($context, $exist:prefix, $exist:controller, '/');</span>
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
    <span class="pre-highlight">&lt;xi:include href="{concat(
        $exist:root, 
        $exist:controller, 
        '/includes/header.xql?title=', 
        encode-for-uri($title),
        '&amp;fqcontroller=',
        $fqcontroller
    )}"/&gt;</span>
    &lt;body&gt;
        &lt;h1&gt;{$title}&lt;/h1&gt;
        &lt;p&gt;Content will go here&lt;/p&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre>
                <p>The link to <i>header.xql</i> is formed by concatenating, in order:</p>
                <ol>
                    <li><code>$exist:root</code> At this point the URL is equal to
                            <code>xmldb:exist:///db/apps</code>. If for any reason we have installed
                        our app into a different location, that different location will nonetheless
                        be reported correctly because eXist-db is reading the actual location,
                        instead of just assuming that it will be the standard one. And because we
                        don’t have an HTTP path (one that starts with something like
                            <code>http://localhost:8080</code>), eXist-db will not make unnecessary
                        and possibly incorrect assumptions about the port on which the eXist-db
                        jetty server is running.</li>
                    <li><code>$exist:controller</code> The path is now equal to
                            <code>xmldb:exist:///db/apps/repertorium</code></li>
                    <li><code>/includes/header.xql</code> This takes us to the location of include
                        files in our app. The path is now equal to
                            <code>xmldb:exist:///db/apps/repertorium/includes/header.xql</code>.</li>
                    <li>We then add a query string to pass parameters from <i>index.xql</i> into
                            <i>header.xql</i>, leading to a final URL of
                            <code>xmldb:exist:///db/apps/repertorium/includes/header.xql?title=encode-for-uri($title)&amp;exist:controller=/repertorium&amp;exist:root=xmldb:exist///db/apps</code>,.
                        We need to encode the title because it may contain characters not permitted
                        in URLs, such as spaces. We are not URL-encoding the controller variables,
                        which is safe only as long as our resource names in the database do not
                        contain those same prohibited characters.</li>
                </ol>
                <!--TODO: Is colon okay in query parameter name, URL-encoded or bare? See eXist book,
                    p. 92.-->
            </section>
            <section id="controller_css">
                <h3>Linking to CSS and JavaScript</h3>
                <p>Finally, once we have passed the parameters into <i>header.xql</i>, our included
                    document, we can use them to construct an absolute path from there to our CSS
                    and JavaScript resources. Our <i>header.xql</i> file looks as follows:</p>
                <pre><![CDATA[xquery version "3.1";]]>
<span class="pre-highlight"><![CDATA[declare variable $title external;
declare variable $fqcontroller external;]]></span>
<![CDATA[<head xmlns="http://www.w3.org/1999/xhtml">]]>
    <span class="pre-highlight"><![CDATA[<title>{$title}</title>
    <link rel="stylesheet" type="text/css" href="{concat($fqcontroller, 'resources/css/style.css')}"/> 
    <link rel="stylesheet" type="text/css" href="{concat($fqcontroller, 'resources/css/repertorium.css')}"/>]]></span>
<![CDATA[</head>]]></pre>
                <p>The constructed links to the CSS in our example look like
                        <code>href="/exist/apps/repertorium/resources/css/style.css"</code>. Links
                    to JavaScript would be constructed similarly.</p>
            </section>
            <section id="controller_home">
                <h3>The main page</h3>
                <p>The main page in our app is <i>index.xql</i>, which can be retrieved with
                        <code>http://localhost:8080/exist/apps/repertorium/index</code>, but we
                    would like it to be the default when no page is specified, that is, when the
                    user enters just <code>http://localhost:8080/exist/apps/repertorium/</code>. We
                    handle this inside the controller by testing whether
                        <code>$exist:resource</code> is null, that is, whether there is anything
                    after the final slash in the URL. If not, the controller forwards the URL to the
                    designated main page:</p>
                <pre>declare variable $home-page-url as xs:string := "index";
                    
if ($exist:resource eq "") then
    &lt;dispatch xmlns="http://exist.sourceforge.net/NS/exist"&gt;
        &lt;redirect url="{$home-page-url}"/&gt;
    &lt;/dispatch&gt;</pre>
                <p>Because this is a redirect, and not a forward, the controller rewrites the URL as
                    if <code>$exist:resource</code> had been specified as <code>index</code> and
                    then sends it through the controller again.</p>
                <p>One limitation to configuring a default page is that the trailing slash must be
                    present, so if the user enters
                        <code>http://localhost:8080/exist/apps/repertorium</code>, without the final
                    slash, the main page will not be loaded. This behavior cannot be controlled by
                    the app controller because the app controller never sees the URL, and it gets
                    handled at a higher level in the database hierarchy. If you have control of your
                    entire eXist-db instance, you can set a forwarding instruction outside the app
                    to handle this contingency.</p>
            </section>
            <section id="controller_extensions">
                <h3>Documents with extensions</h3>
                <section id="controller_extensions_xql">
                    <h4>The <i>.xql</i> extension</h4>
                    <p>The controller example above assumes that URLs that end in resources without
                        explicit extensions are XQuery scripts, and it rewrites the URLs
                        accordingly. If the user specifies the <i>.xql</i> extension, the URL will
                        not be rewritten (see below), so a path like
                            <code>http://localhost:8080/exist/apps/repertorium/index.xql</code> will
                        raise an error. Furthermore,
                            <code>http://localhost:8080/exist/apps/repertorium/modules/index.xql</code>,
                        which specifies the <i>modules</i> subcollection and the <i>.xql</i>
                        extension explicitly, will now also raise an error because it has been
                        revised to expect to receive the controller variables from the controller.
                        If you are concerned about users entering URLs with explicit <i>.xql</i>
                        extensions, it is possible to add an additional test condition in the
                        controller to handle it, but we have not done that in the present
                        example.</p>
                </section>
                <section id="controller_extensions_other">
                    <h4>Other extensions</h4>
                    <p>We assume that all resources with extensions should be passed through without
                        rewriting. This includes primarily resources in the <i>resources</i>
                        subcollection, such as images and CSS.</p>
                </section>
            </section>
            <section id="controller_conclusion">
                <h3>Controller summary</h3>
                <p>The controller configuration described above handles three types of URL:</p>
                <ul>
                    <li>If there is a resource name with an extension, the URL is not rewritten and
                        the resource is returned.</li>
                    <li>If there is a resource name without an extension, it is presumed to be an
                        XQuery script, and the URL is rewritten to specify the <i>modules</i>
                        subcollection and the <i>.xql</i> extension.</li>
                    <li>If there is no resource name, the controller supplies the resource name of
                        the main page as a default.</li>
                </ul>
            </section>
        </section>
        <section id="xslt">
            <h2>Transform your XQuery results to HTML with XSLT</h2>
            <section id="xslt_preliminaries">
                <h3>XSLT within the eXist-db app context</h3>
                <p>When the eXist-db <i>controller.xql</i> script rewrites a URL to point to an
                    XQuery script, it can also specify that the output of the script should be
                    passed through an XSLT transformation before being rendered. This is part of an
                        <dfn>MVC</dfn> (<dfn>model, view, controller</dfn>) architecture, where the
                    output of the XQuery is the <dfn>model</dfn> (that is, the informational
                    content), <i>controller.xql</i> is the <dfn>controller</dfn> (which manages the
                    information), and the controller uses an XSLT stylesheet to create the
                        <dfn>view</dfn> by transforming the model into HTML.</p>
                <p class="note">eXist-db support for pipelining is richer than just pushing the
                    content through a single XSLT transformation. For more information see
                        <q>Advanced URL control</q> in Chapter 9 of Siegel and Retter, pp. 203–05.
                    It is also possible to execute an XSLT transformation as part of an XQuery
                    script, rather than as a separate pipelined operation, by using the eXist-db
                        <code>transform:transform()</code> function. (The <a
                        href="https://www.w3.org/TR/xpath-functions-31/#func-transform">XPath 3.1
                        core <code>transform()</code> function</a> is not currently supported by
                    eXist-db.) For more information about <code>transform:transform()</code> see <a
                        href="http://exist-db.org/exist/apps/doc/xsl-transform"
                        >http://exist-db.org/exist/apps/doc/xsl-transform</a>. Within the eXist-db
                    app context, we find it easier to manage XSLT with the controller.</p>
            </section>
            <section id="xslt_view">
                <h3>The controller <code>&lt;view&gt;</code> element</h3>
                <p>To pipe the output of an XQuery script through XSLT before returning it, add a
                        <code>&lt;view&gt;</code> element after the <code>&lt;forward&gt;</code>
                    element inside the controller. The following example is from Siegel and Retter,
                    p. 203:</p>
                <pre><![CDATA[<dispatch xmlns="http://exist.sourceforge.net/NS/exist">
    <forward url="{concat($exist:controller, "/createmodel.xq")}"/>]]>
    <span class="pre-highlight"><![CDATA[<view>
        <forward servlet="XSLTServlet">
            <set-attribute name="xslt.stylesheet"
                value="{concat($exist:root, $exist:controller, "/xslt/view1.xslt")}"/>
        </forward>
    </view>]]></span>
<![CDATA[</dispatch>]]></pre>
                <p>The <code>&lt;view&gt;</code> element contains another
                        <code>&lt;forward&gt;</code> element, which has a
                        <code>&lt;set-attribute&gt;</code> child that specifies the XSLT stylesheet.
                    Other parameters may be passed (as strings) with additional
                        <code>&lt;set-attribute&gt;</code> elements, which must have a
                        <code>@name</code> attribute that begins with the string <code>xslt.</code>.
                    For example, an attribute called <code>xslt.myattr</code> is available within
                    the XSLT as an <code>$xslt.myattr</code> parameter. For more information about
                    using the XSLT servlet in an eXist-db app context, see <a
                        href="http://exist-db.org/exist/apps/doc/urlrewrite.xml"
                        >http://exist-db.org/exist/apps/doc/urlrewrite.xml</a>.</p>
            </section>
        </section>
        <section id="generate">
            <h2>Generate your app</h2>
            <ol>
                <li>Verify that the owner and group of every collection and file are the owner and
                    group ids that you created originally in the eXide app wizard. Verify also that
                    the resource permissions are correct: anything users should be able to read
                    directly must be world-readable, and any XQuery that users should be able to run
                    should be world-executable. Directories where users need to access resources
                    must also be world-readable and world-executable. The easiest way to set these
                    properties for multiple resources simultaneously is to use
                        <code>sm:chown()</code> and <code>sm:chmod()</code> inside an XQuery
                        <code>for</code> loop.</li>
                <li>To generate your app, open any file from within the app hierarchy in eXide. Then
                    go to Application → Download app. An <i>.xar</i> file will be downloaded into
                    the file system on the server where eXist-db is running.</li>
            </ol>
            <p>We also recommend using Application → Synchronize within eXide to export your app to
                a GitHub repo on your local filesystem. Although the instruction is called
                    <q>synchronize</q>, it only downloads from eXist-db to the file system. Since
                changes made directly on the filesystem are not uploaded during synchronization, our
                preferred strategy is to work entirely within the app inside eXist-db, and to run a
                sequence of synchronize (from within eXide) and then add, commit, and push (from the
                command line), as with a normal Git repo.</p>
        </section>
        <section id="misc">
            <h2>Fine tuning</h2>
            <p><strong>TODO: Customize boilerplate according to including document</strong></p>
            <p><strong>TODO: Simplify URL to remove <i>/exist</i></strong></p>
            <p><strong>TODO: Proxy to remove port number</strong></p>
            <p><strong>TODO: Apply XSLT only where needed</strong></p>
        </section>
        <hr />
        <section id="variable_output">
            <h2 class="unnumbered">Appendix A: Controller variables and <code>request:</code>
                functions</h2>
            <p>The following three XQuery scripts output the table of controller variables and
                    <code>request:</code> function results illustrated in <a
                    href="#controller_example">Examining controller variables and
                        <code>request:</code> function values</a>, above. When the user navigates to
                    <code>http://localhost:8080/exist/db/apps/repertorium/test</code>,
                    <i>controller.xql</i> rewrites the query to point to a <i>test.xql</i> script
                inside a <i>modules</i> subcollection, forwarding to it the five default controller
                variables plus the output of two functions in the <code>request:</code> namespace.
                The <i>test.xql</i> script creates the table, and also XIncludes <i>header.xql</i>,
                forwarding to it the parameters it needs to create content for
                    <code>&lt;title&gt;</code> and links to CSS.</p>
            <section id="variable_output_controller">
                <h3 class="unnumbered"><i>controller.xql</i></h3>
                <p><i>controller.xql</i> is located inside <i>/db/apps/repertorium</i></p>
                <pre><![CDATA[xquery version "3.1" encoding "UTF-8";

(: External variables available to the controller:
 : $exist:root
 :      The path to where the app is installed, typically xmldb:exist:///db/apps
 : $exist:prefix
 :      The location within the database, specified in controller-config.xml on the
 :      server, where eXist begins looking for a controller, typically /apps 
 : $exist:controller
 :      The part of the URL leading from the prefix (typically /apps) to the controller 
 :      script. Often the root collection of the app, for example: /repertorium
 : $exist:path
 :      The part of the URL below the controller to the request resource. For example: 
 :      /a/b/c.xq.
 : $exist:resource
 :      The part of the URL after the last / character, usually pointing to a 
 :      resource. For example: c.xq
 : :)
declare variable $exist:root external;
declare variable $exist:prefix external;
declare variable $exist:controller external;
declare variable $exist:path external;
declare variable $exist:resource external;

(: Other variables :)
declare variable $uri as xs:anyURI := request:get-uri();
declare variable $context as xs:string := request:get-context-path();
declare variable $home-page-url as xs:string := "index";

(: Function to get the extension of a filename: :)
declare function local:get-extension($filename as xs:string) as xs:string {
    let $name := replace($filename, ".*[/\\]([^/\\]+)$", "$1")
    return
        if (contains($name, "."))
        then
            replace($name, ".*\.([^\.]+)$", "$1")
        else
            ""
};

(: If there is no resource specified, go to the home page.
This is a redirect, forcing the browser to perform a redirect. So this request
will pass through the controller again... :)
if ($exist:resource eq "") then
    <dispatch xmlns="http://exist.sourceforge.net/NS/exist">
        <redirect url="{$home-page-url}"/>
    </dispatch>
    
(: Check if there is no extension. If not, assume it is an XQuery file and located
 : in the modules subcollection. Because we use forward here, the browser will not be 
informed of the change and the user will see a URL without the "modules/" step in the
path and with the ".xql" extension. :)
else
if (local:get-extension($exist:resource) eq "") then
    <dispatch xmlns="http://exist.sourceforge.net/NS/exist">
        <forward url="{concat(
            $exist:controller, 
            substring-before($exist:path, $exist:resource), 
            "modules/", 
            $exist:resource, 
            ".xql"
        )}">
            <add-parameter name="exist:root" value="{$exist:root}"/>
            <add-parameter name="exist:prefix" value="{$exist:prefix}"/>
            <add-parameter name="exist:controller" value="{$exist:controller}"/>
            <add-parameter name="exist:path" value="{$exist:path}"/>
            <add-parameter name="exist:resource" value="{$exist:resource}"/>
            <add-parameter name="uri" value="{$uri}"/>
            <add-parameter name="context" value="{$context}"/>
        </forward>
    </dispatch>
(: Anything else, pass through: :)
    else
        <ignore xmlns="http://exist.sourceforge.net/NS/exist">
            <cache-control cache="yes"/>
        </ignore>]]></pre>
            </section>
            <section id="controller_output_test">
                <h3 class="unnumbered"><i>test.xql</i></h3>
                <p><i>test.xql</i> is located inside <i>/db/apps/repertorium/modules</i></p>
                <pre><![CDATA[xquery version "3.1";
declare default function namespace "http://www.w3.org/2005/xpath-functions";
declare default element namespace "http://www.w3.org/1999/xhtml";
declare namespace xi = "http://www.w3.org/2001/XInclude";
declare namespace output = "http://www.w3.org/2010/xslt-xquery-serialization";
declare option output:method "xml";
declare option output:media-type "application/xhtml+xml";
declare option output:omit-xml-declaration "no";
declare option output:indent "no";
declare option output:doctype-system "about:legacy-compat";
declare variable $title as xs:string := "eXist-db variables available to XQuery scripts";
declare variable $exist:root as xs:string := request:get-parameter("exist:root", ());
declare variable $exist:prefix as xs:string := request:get-parameter("exist:prefix", ());
declare variable $exist:controller as xs:string := request:get-parameter("exist:controller", ());
declare variable $exist:path as xs:string := request:get-parameter("exist:path", ());
declare variable $exist:resource as xs:string := request:get-parameter("exist:resource", ());
declare variable $uri as xs:string := request:get-parameter("uri", ());
declare variable $context as xs:string := request:get-parameter("context", ());
declare variable $fqcontroller as xs:string := concat($context, $exist:prefix, $exist:controller, '/');
<html
    xmlns="http://www.w3.org/1999/xhtml">
    <xi:include
        href="{
                concat(
                $exist:root,
                $exist:controller,
                '/includes/header.xql?title=',
                encode-for-uri($title),
                '&amp;fqcontroller=',
                $fqcontroller
                )
            }"/>
    <body>
        <h1>{$title}</h1>
        <table>
            <tr><th>Variable</th><th>Value</th></tr>
            <tr><td><code>$title</code></td><td>{$title}</td></tr>
            <tr><td><code>$exist:root</code></td><td>{$exist:root}</td></tr>
            <tr><td><code>$exist:prefix</code></td><td>{$exist:prefix}</td></tr>
            <tr><td><code>$exist:controller</code></td><td>{$exist:controller}</td></tr>
            <tr><td><code>$exist:path</code></td><td>{$exist:path}</td></tr>
            <tr><td><code>$exist:resource</code></td><td>{$exist:resource}</td></tr>
            <tr><td><code>$uri</code> (from <code>request:get-uri()</code>)</td><td>{$uri}</td></tr>
            <tr><td><code>$context</code> (from <code>request:get-context-path()</code>)</td><td>{$context}</td></tr>
            <tr>
                <td><code>$fqcontroller</code><br/>(<code>concat($context, $exist:prefix, $exist:controller, '/')</code>)</td>
                <td>{$fqcontroller}</td>
            </tr>
        </table>
    </body>
</html>]]></pre>
            </section>
            <section id="controller_output_header">
                <h3 class="unnumbered"><i>header.xql</i></h3>
                <p><i>header.xql</i> is located inside <i>/db/apps/repertorium/includes</i></p>
                <pre><![CDATA[xquery version "3.1";
declare variable $title external;
declare variable $fqcontroller external;
<head xmlns="http://www.w3.org/1999/xhtml">
    <title>{$title}</title>
    <link rel="stylesheet" type="text/css" href="{concat($fqcontroller, 'resources/css/style.css')}"/> 
    <link rel="stylesheet" type="text/css" href="{concat($fqcontroller, 'resources/css/repertorium.css')}"/>
</head>]]></pre>
            </section>
        </section>
        <section id="paths">
            <h2 class="unnumbered">Appendix B: Path summary</h2>
            <p>From within <i>controller.xql</i>, a forwarding URL should begin with
                    <code>$exist:controller</code>, e.g.:</p>
            <pre><![CDATA[<dispatch xmlns="http://exist.sourceforge.net/NS/exist">
    <forward url="{]]><span class="pre-highlight"><![CDATA[concat(
        $exist:controller, 
        substring-before($exist:path, $exist:resource), 
        "modules/", 
        $exist:resource, ".xql"
    )]]></span><![CDATA[}"/>
</dispatch>]]></pre>
            <p>From within an XQuery script, a path to a system resource that will be used by the
                script, e.g., an XML document called with <code>doc()</code> or a collection called
                with <code>collection()</code>, should begin with <code>$exist:root</code>,
                e.g.:</p>
            <pre><![CDATA[<xi:include href="{concat(
    $exist:root, 
    $exist:controller, 
    '/includes/header.xql?title=', 
    encode-for-uri($title),
    '&fqcontroller=',
    $fqcontroller
)}"/>]]></pre>
            <p>The same type of path is used for XSLT stylesheets, e.g.:</p>
            <pre><![CDATA[<view>
    <forward servlet="XSLTServlet">
        <set-attribute name="xslt.stylesheet"
            value="{concat($exist:root, $exist:controller, "/xslt/view1.xslt")}"/>
    </forward>
</view>]]></pre>
            <p>From within an XQuery script, a path to a system resource that will be processed by
                the jetty server, e.g., to CSS or JavaScript, should begin with the context
                (typically <i>/exist</i>), which can be retrieved with
                    <code>request:get-context-path()</code>, e.g.:</p>
            <pre><![CDATA[<link rel="stylesheet" type="text/css" 
    href="{concat(request:get-context-uri(), $exist:prefix, $exist:controller, '/resources/css/style.css')}"/>]]></pre>
        </section></body>
</html>
