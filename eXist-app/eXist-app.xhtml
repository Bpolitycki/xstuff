<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Creating an eXist-db application</title>
        <link rel="stylesheet" type="text/css" href="http://www.obdurodon.org/css/style.css" />
        <style type="text/css">
            q {
                font-style: regular;
            }
            h1 {
                counter-reset: h2;
            }
            h2.unnumbered:before {
                /* setting display to none both suppresses output and removes the element from the count */
                display: none;
            }
            h2:before {
                counter-increment: h2;
                content: counter(h2) '. ';
            }
            h2 {
                counter-reset: h3;
            }
            h3:before {
                counter-increment: h3;
                content: counter(h2) '.' counter(h3) '. ';
            }
            h3 {
                counter-reset: h4;
            }
            h4:before {
                counter-increment: h4;
                content: counter(h2) '.' counter(h3) '.' counter(h4) '. '}</style>
        <!-- Markup based on eXist boook, p. 12
                
                Italic: Indicates new terms, URLs, email addresses, file- and pathnames, 
                database collections, and file extensions. Here: <i> ... </i>
                
                Constant width: Used for program listings, as well as within paragraphs to 
                refer to program elements such as variable or function names, module names, 
                data types, environment variables, statements, and keywords. Also used for 
                commands and command-line output, database user and group names, and permission 
                modes. Here: <code> ... </code>
                
                Constant width italic: Shows text that should be replaced with user-supplied 
                values or by values determined by context. Here: <code><i> ... </i></code>.
                
                Added: 
                    Values chosen or entered by users are tagged a <q> ... </q>; this includes
                        the names of buttons. This styling overrides other markup, e.g., if the user 
                        is to enter a filename or a user or group name, it is quoted but not italic 
                        or constant width.
                    The name eXist-db is used (instead of just eXist).
                    Names of programs (e.g., eXist, eXide) are not styled. Neither are names of
                        dialogs (e.g., Open . document), the labels on dialog widgets (e.g., Template),
                        or menu items (e.g., Application or New application).
            -->
    </head>
    <body>
        <h1>Creating an eXist-db application</h1>
        <p>David J. Birnbaum, 2018-11-07, CC-BY-SA</p>
        <section id="introduction">
            <h2 class="unnumbered">Introduction</h2>
            <p>This tutorial describes the process for creating an application within eXist-db. This
                method uses eXist-db not only as an XML database, but also as a content management
                system (CMS), which means that all application resources (for the model, controller,
                and view) are packaged into a single <i>.xar</i> file that can be hot-deployed into
                any running eXist-db instance. This type of app provides a self-contained
                alternative to the familiar architecture in which an HTML/PHP front end, typically
                running on an Apache or Nginx HTTP server, queries eXist-db only to retrieve
                information, but otherwise manages the front end itself, including both accepting
                user input and formatting output (for more information about this approach see <a
                    href="http://dh.obdurodon.org/php-xquery.xhtml"
                    >http://dh.obdurodon.org/php-xquery.xhtml</a>). The principal advantage of the
                eXist-db app architecture described here is greater ease of maintenance and
                deployment, since there is no dependency on communication with an independent web
                server. The principal disadvantage of the eXist-db app approach is greater
                dependence on eXist-db, since much of the eXist-db app functionality is specific to
                eXist-db, and cannot be transferred directly, without modification, into an
                alternative XML database. The difference between the eXist-db app and the HTML/PHP
                architecture lies ultimately in the extent of the dependency, which is present to
                some measure in any case because not all aspects of interacting with an XML database
                are addressed in the standards to which all XML databases seek to conform.</p>
            <p>eXist-db incorporates support for two further aspects of app development that are not
                addressed in this tutorial. One is that the eXide app wizard within eXist-db enables
                the configuration of Bootstrap CSS support within a new eXist-db app. We prefer not
                to use Bootstrap (in this tutorial and in our real work) because we have better
                control over styling when we manage all CSS directly ourselves. The other is that
                eXist-db supports an HTML templating framework, which, in MVC terminology, separates
                the view more clearly from the controller than we do in the process described below.
                We avoid HTML templating in order to control includes more explicitly. Users who
                prefer to avail themselves of these features can learn more about them in the
                following sources, which are recommended reading in any case:</p>
            <ul>
                <li><a href="http://exist-db.org/exist/apps/doc/development-starter"
                        >http://exist-db.org/exist/apps/doc/development-starter</a>, which
                    introduces eXist-db app development. This page can be consulted together with <a
                        href="http://exist-db.org/exist/apps/doc/templating.xml"
                        >http://exist-db.org/exist/apps/doc/templating.xml</a>, which introduces and
                    describes HTML templating.</li>
                <li>Chapter 9, <q>Building applications</q>, of Erik Siegel and Adam Retter’s
                        <cite>eXist</cite>, Beijing et al.: O’Reilly, 2014, pp. 191–235.</li>
            </ul>
            <p>The stages in the procedure for developing an eXist-db app are described below in the
                following order:</p>
            <ol>
                <li><a href="#skeleton">Create a new app skeleton</a></li>
                <li><a href="#directories">Expand the skeleton</a></li>
                <li><a href="#content">Add XML content and non-XML resources</a></li>
                <li><a href="#indexing">Add support for indexing</a></li>
                <li><a href="#xquery">Create some XQuery scripts</a></li>
                <li><a href="#xinclude">Modularize with XInclude</a></li>
                <li><a href="#controller">Configure <i>controller.xql</i></a></li>
                <li><a href="#enerate">Generate your app</a></li>
            </ol>
            <p>The procedure described here was tested under eXist-db 4.4. This tutorial
                concentrates only on app development, and it is intended for users who already have
                a basic familiarity with XQuery and with the use of eXist-db as an XML database.
                Those who lack that familiarity will need to begin with the online eXist
                documentation and the <cite>eXist</cite> book mentioned above before proceeding to
                app development. In keeping with common XQuery terminology (e.g., Erik Siegel and
                Adam Retter’s <cite>eXist</cite>, Beijing et al.: O’Reilly, 2014, p. 40), we observe
                the following terms:</p>
            <ol>
                <li><dfn>collection</dfn>: Comparable to a <dfn>directory</dfn> in the filesystem or
                    a <dfn>folder</dfn> in a GUI. Collections are hierarchical, so a collection may
                    contain <dfn>subcollections</dfn>.</li>
                <li><dfn>resource</dfn>: Comparable to a <dfn>file</dfn> in the filesystem. What is
                    a <dfn>filename</dfn> in the filesystem is a <dfn>resource name</dfn> in
                    eXist-db, a <dfn>filename extension</dfn> is a <dfn>resource name
                        extension</dfn>, and a <dfn>file type</dfn> is a <dfn>resource type</dfn>.
                    Resources may be XML, XQuery, or anything else.</li>
                <li><dfn>document</dfn>: An XML resource. Because XQuery may be used to create XML,
                    in the context of XInclude and other inclusions we may refer metonymically to
                    XQuery resources that generate XML as the <dfn>master document</dfn> and the
                        <dfn>included document</dfn>, even though either may be an XQuery script
                    that evaluates to an XML document, and not an actual XML document.</li>
                <li><dfn>script</dfn>: An XQuery resource.</li>
            </ol>
            <p>Because we sometimes upload files from the filesystem into eXist-db, where they
                become resources, we will also use filesystem-based terms as appropriate.</p>
        </section>
        <section id="skeleton">
            <h2>Create a new app skeleton</h2>
            <p>Start by using the app creation wizard inside eXide to create a skeleton for your new
                app.</p>
            <ol>
                <li>Inside eXide, choose Application → New application and authenticate as userid
                        <q>admin</q> or another user who is a member of the <code>dba</code>
                    (database administrator) group. This opens the app-creation wizard.</li>
                <li>Set Template to <q>Empty package</q>, Type of package to <q>Application</q>, and
                    Target collection to the bare name of your collection (that is, do not specify a
                    path). This assumes that you want to deploy the app into the standard location,
                    which is inside <i>/db/apps</i>; for example, a collection named
                        <q>repertorium</q> will be deployed to <i>/db/apps/repertorium</i> (and, for
                    that reason, do not use spaces or punctuation in the name of the Target
                    collection). Set the Name to a URI (it does not have to be an existing URL; it’s
                    an identifier, and not a location). Enter a Short name (which will be used as
                    the root of the filename for the eventual <i>.xar</i> archive, so don’t use any
                    spaces or punctuation here, either) and Title (which will be displayed in the
                    dashboard). Leave the Version as <q>0.1</q> (default) and the Status as
                        <q>Alpha</q> (default). Leave the Pre-install XQuery as
                        <q>pre-install.xql</q> and the Post-install XQuery as
                        <q>post-install.xql</q> (defaults). Click <q>Next</q>.</li>
                <li>Type your name into the Author field. You can add other authors later, if you
                    want; adding them with the Add button initially can be awkward. Enter an
                    optional description of the app under Description and a link to your principal
                    web site (you, not the app) under Website (these will be displayed in the
                    Package manager when the user clicks the button for more information). Click
                        <q>Next</q>.</li>
                <li>Create a userid for the Owner, create a password as the Password, and create a
                    groupid as the Group. Although it is possible to use existing credentials, we
                    recommend creating a unique user, group, and password just for the app, and
                    setting the name of the group to match that of the user. It is not necessary to
                    use an account with elevated privileges (e.g., <code>admin</code>, or any member
                    of the <code>dba</code> group). Leave Mode as <code>rw-rw-r--</code> (default).
                    Click <q>Done</q>.</li>
            </ol>
            <p>eXist-db should display an Open document dialog pointing to your collection, which
                should contain three documents: <i>build.xml</i>, <i>expath-pkg.xml</i>, and
                    <i>repo.xml</i>. Note that the wizard does not create any controller or index
                documents for your app, or pre-install or post-install scripts, so you’ll need to
                configure those separately, as described below.</p>
        </section>
        <section id="directories">
            <h2>Expand the skeleton</h2>
            <ol>
                <li>Inside the root collection of your app (e.g., <i>/db/apps/repertorium</i>)
                    create subcollections to hold different types of content. In this example we
                    create the following subcollections: <ul>
                        <li><i>mss</i> In the Repertorium project, these are our principal XML
                            documents, which are manuscript descriptions in TEI XML. Your app might
                            use a more generic subcollection name, such as <i>xml</i> or
                            <i>data</i>.</li>
                        <li><i>aux</i> Auxiliary XML documents. In the Repertorium project, these
                            include a master bibliography and documents with master lists of article
                            names and genres.</li>
                        <li><i>modules</i> XQuery scripts</li>
                        <li><i>xslt</i> XSLT stylesheets, used to transform the results of queries
                            executed with XQuery</li>
                        <li><i>resources</i> These are auxiliary materials that may or may not be
                            XML. In the Repertorium project this holds five subcollections:<ul>
                                <li><i>pdf</i> PDF resources</li>
                                <li><i>js</i> JavaScript resources</li>
                                <li><i>css</i> CSS resources (with webfonts in a <i>fonts</i>
                                    subcollection under <i>css</i>)</li>
                                <li><i>includes</i> Static content that is inserted into XQuery
                                    output, similarly to server-side includes in a traditional
                                    Apache web app. In our example, this includes SVG</li>
                                <li><i>images</i> Static image resources (note that we’ve chosen to
                                    put static SVG graphics under <i>includes</i>, so our
                                        <i>images</i> collection contains just raster images)</li>
                            </ul></li>
                    </ul></li>
                <li>Optionally upload a file named <i>icon.png</i> into the root collection of your
                    app. If you include this, it will be displayed in the dashboard (at an
                    appropriate size); otherwise a generic eXist-db icon will be used. (This feature
                    does not appear to be documented officially.)</li>
            </ol>
            <p>In most cases you will want to set the user and group for all resources to the userid
                and groupid you created when you configured the wizard, and if you create the
                resources above while you are authenticated as <code>admin</code> or another
                privileged user, the owner and group of the new resources will be set to values for
                that privileged user. You can reset the values now or defer that operation until the
                end, after you’ve created all of your content (see <a href="#generate">Generate your
                    app</a>, below).</p>
        </section>
        <section id="content">
            <h2>Add XML content and non-XML resources</h2>
            <ol>
                <li>Upload or create some XML documents (in this examples, in the <i>mss</i> and
                        <i>aux</i> subcollections).</li>
                <li>Upload or create content for the subcollections under <i>resources</i>, e.g.,
                    JavaScript, CSS, images, and boilerplate XML snippets.</li>
            </ol>
        </section>
        <section id="indexing">
            <h2>Add support for indexing</h2>
            <p>The skeleton does not contain either index documents or the code needed to deploy
                those into the correct location when the app is installed. We fix that by creating
                our own <i>pre-install.xql</i> script.</p>
            <ol>
                <li>Create a script called <i>pre-install.xql</i> with the following content and
                    upload or install it into the root collection of your app:
                    <pre>xquery version "3.0";

import module namespace xdb="http://exist-db.org/xquery/xmldb";

(: The following external variables are set by the repo:deploy function :)

(: file path pointing to the exist installation directory :)
declare variable $home external;
(: path to the directory containing the unpacked .xar package :)
declare variable $dir external;
(: the target collection into which the app is deployed :)
declare variable $target external;

declare function local:mkcol-recursive($collection, $components) {
    if (exists($components)) then
        let $newColl := concat($collection, "/", $components[1])
        return (
            xdb:create-collection($collection, $components[1]),
            local:mkcol-recursive($newColl, subsequence($components, 2))
        )
    else
        ()
};

(: Helper function to recursively create a collection hierarchy. :)
declare function local:mkcol($collection, $path) {
    local:mkcol-recursive($collection, tokenize($path, "/"))
};

(: store the collection configuration :)
local:mkcol("/db/system/config", $target),
xdb:store-files-from-pattern(concat("/db/system/config", $target), $dir, "*.xconf")</pre>
                    This instructs eXist-db to copy a <i>collection.xconf</i> (index) document from
                    the app root collection into the appropriate location upon deployment. If you
                    have index documents in subcollections, you need to use an alternative form of
                    the <code>xdb:store-files-from-pattern()</code> function, one that looks into
                    subcollections, such as the following, where  <code>**/collection.xconf</code>
                    matches documents in any directory below the current one, and copies them at the
                    correct corresponding level under
                    <i>/db/config/system/db/</i>:<pre> xdb:store-files-from-pattern(concat("/db/system/config", $target), $dir, "**/collection.xconf", "application/xml", true())</pre></li>
                <li>Create <i>collection.xconf</i> documents inside any subcollections that you wish
                    to index individually. Note that index documents must have the resource
                    extension <i>.xconf</i> (we recommend using the traditional document name
                        <i>collection.xconf</i>) and must be created inside the regular app
                    hierarchy, even though that is not where eXist-db normally looks for them in
                    order to build indexes. If you edit index documents during development, you’ll
                    need to keep the copy inside the app hierarchy, which is needed for deployment,
                    in sync with the one that eXist-db actually uses, under
                        <i>/db/config/system/db/apps/</i>. You can read more about configuring
                    indexes at <a href="http://exist-db.org/exist/apps/doc/indexing"
                        >http://exist-db.org/exist/apps/doc/indexing</a> or in Chapter 11, <q>Basic
                        indexing</q> and Chapter 12, <q>Text indexing and lookup</q> of Erik Siegel
                    and Adam Retter’s <cite>eXist</cite>, Beijing et al.: O’Reilly, 2014, pp.
                    271–302.</li>
            </ol>
            <p>eXist-db automatically indexes new XML documents as they are uploaded into the
                database, and eXide prompts you to reindex the collection whenever you edit an index
                document in place. But eXist-db does not automatically run the indexing procedure
                when you upload a new <i>collection.xconf</i> index. This means that if you upload
                    <i>collection.xconf</i> files during development, you should reindex the
                collection explicitly.</p>
        </section>
        <section id="xquery">
            <h2>Create some XQuery scripts</h2>
            <section id="xquery_preliminaries">
                <h3>XQuery preliminaries in the context of eXist-db apps</h3>
                <p>Create XQuery scripts inside the <i>modules</i> subcollection. We observe the
                    recommendation in Erik Siegel and Adam Retter’s <cite>eXist</cite>, Beijing et
                    al.: O’Reilly, 2014, p. xiv and use the filename extension <i>.xql </i>for all
                        <dfn>main modules</dfn>, that is, XQuery scripts that are meant to be called
                    and executed directly. Where we use XQuery library modules, which are not meant
                    to be executed, and which contain only functions that are meant to be imported
                    into main modules or other libraries, we use the filename extension <i>.xqm</i>.
                    Our projects do not use any other filename extension for XQuery files.</p>
                <p>The <i>.xql</i> files inside <i>modules</i> will be responsible for creating the
                    content that will eventually be shown to users, some customized in response to
                    user input (e.g., queries that act on information supplied by the user in web
                    forms) and some in a relatively static way (that is, without customization in
                    response to user input). Although it is possible to serve static HTML from
                    eXist-db in this second situation, instead of using XQuery to create it, we
                    recommend using XQuery to create all output. The reason for this recommendation
                    is that we will use XQuery to manage the inclusion of boilerplate snippets, of
                    the sort that might have been handled with server-side includes (SSI) or PHP
                    includes on a traditional web site. Using XQuery to create all output is a
                    convenient way to apply the include process to all content before returning a
                    result to the user.</p><p>Although we use XQuery to construct all output, we
                    treat static output differently from output created in response to user-supplied
                    parameters, as follows:</p><ul>
                    <li>In the case of static output, our XQuery creates HTML and serializes it
                        directly.</li>
                    <li>In the case of output that is constructed according to user-supplied
                        parameters, XQuery retrieves information from source XML, often with its
                        original non-HTML markup, and then pipes it through an XSLT transformation
                        before returning the result to the user as HTML.</li>
                </ul><p>While it might seem simpler to treat all XQuery identically, and to pass all
                    XQuery output through XSLT before returning it to the user, launching an XSLT
                    process entails overhead. For that reason, we use XSLT only where it is actually
                    needed.</p><p class="note">Some developers avoid XSLT entirely, preferring to
                    transform content by using the XQuery <code>typeswitch()</code> function to
                    simulate XSLT template processing. In this tutorial, as in our actual projects,
                    we use the XSLT approach.</p>All HTML output from our projects is HTML 5.0 with
                XML syntax. We therefore use the HTML namespace, and we set the eXist-db output
                    <code>method</code> to <q>xml</q>, the <code>media-type</code> to
                    <q>application/xhtml+xml</q>, and <code>indent</code> to <q>no</q>. We include
                an XML declaration in HTML to be returned, but we set
                    <code>omit-xml-declaration</code> to <q>yes</q> when we generate XML that will
                be included into a larger context before being transformed and returned to the
                user.</section>
            <section id="xquery_main">
                <h3>Create a main page</h3>
                <p>Create a main page, called <i>index.xql</i>, inside the <i>modules</i>
                    subcollection. We will learn later how to make it the default (when the user
                    does not specify a page), how to simplify the URL (so that, for example, you
                    don’t have to specify <i>modules</i>, or even <i>index.xql</i>, as part of the
                    address), how to incorporate CSS and JavaScript, what links to other pages in
                    the app should look like, and how to include boilerplate content (e.g., a
                    consistent, page-independent header or menu). The first, simplest version of our
                    sample main page looks as follows:</p>
                <pre><![CDATA[xquery version "3.1";
declare default function namespace "http://www.w3.org/2005/xpath-functions";
declare default element namespace "http://www.w3.org/1999/xhtml";
declare namespace output = "http://www.w3.org/2010/xslt-xquery-serialization";
declare option output:method "xml";
declare option output:media-type "application/xhtml+xml";
declare option output:omit-xml-declaration "no";
declare option output:indent "no";
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>My awesome eXist-db app</title>
    </head>
    <body>
        <h1>My awesome eXist-db app</h1>
        <p>Content will go here</p>
    </body>
</html>]]></pre>
            </section>
            <section id="xquery_css">
                <h3>Add CSS and JavaScript to the main page</h3>
                <p>CSS and JavaScript are incorporated into a page the same way they are with
                    traditional HTML, using <code>&lt;link&gt;</code> for CSS and
                        <code>&lt;script&gt;</code> for JavaScript. Links are relative to the page
                    being processed, so if we create <i>style.css</i> in the <i>resources/css</i>
                    collection and JavaScript in the <i>resources/js</i> collection, we can link to
                    them by modifying <i>index.xql</i> as follows (new code added to the first
                    example, above, is highlighted):</p>
                <pre><![CDATA[xquery version "3.1";
declare default function namespace "http://www.w3.org/2005/xpath-functions";
declare default element namespace "http://www.w3.org/1999/xhtml";
declare namespace output = "http://www.w3.org/2010/xslt-xquery-serialization";
declare option output:method "xml";
declare option output:media-type "application/xhtml+xml";
declare option output:omit-xml-declaration "no";
declare option output:indent "no";
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>My awesome eXist-db app</title>]]>
        <span class="pre-highlight"><![CDATA[<link rel="stylesheet" type="text/css" href="../resources/css/style.css"/>
        <script type="text/javascript" src="../resources/js/greet.js"></script>]]></span>
<![CDATA[    </head>
    <body>
        <h1>My awesome eXist-db app</h1>
        <p>Content will go here</p>
    </body>
</html>]]></pre>
                <p>Because our XQuery scripts are in our <i>modules</i> subcollection, these
                    relative paths climb up from there to the app root collection and then down to
                    where the CSS and JavaScript files are located. Because Best Practice in
                    eXist-db is to use absolute paths wherever possible, we’ll change the relative
                    paths to absolute paths below, once we have created a <i>controller.xql</i>
                    file.</p>
            </section>
            <section id="xquery_variables">
                <h3>Use variables to avoid repetition</h3>
                <p>The example above repeats the same text as the content of the
                        <code>&lt;title&gt;</code> element inside the <code>&lt;head&gt;</code> and
                    the <code>&lt;h1&gt;</code> at the beginning of the <code>&lt;body&gt;</code>.
                    Consistent with <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself"
                            ><dfn>DRY</dfn> (<q>Don’t Repeat Yourself</q>)</a>, we can avoid the
                    repetition by abstracting the text into a variable:</p>
                <pre>xquery version "3.1";
declare default function namespace "http://www.w3.org/2005/xpath-functions";
declare default element namespace "http://www.w3.org/1999/xhtml";
declare namespace output = "http://www.w3.org/2010/xslt-xquery-serialization";
declare option output:method "xml";
declare option output:media-type "application/xhtml+xml";
declare option output:omit-xml-declaration "no";
declare option output:indent "no";
<span class="pre-highlight">declare variable $title as xs:string := "My awesome eXist-db app";</span>
<![CDATA[<html xmlns="http://www.w3.org/1999/xhtml">
    <head>]]>
        <span class="pre-highlight"><![CDATA[<title>{$title}</title>]]></span>
        <![CDATA[<link rel="stylesheet" type="text/css" href="../resources/css/style.css"/>
        <script type="text/javascript" src="../resources/js/greet.js"></script>
    </head>
    <body>]]>
        <span class="pre-highlight"><![CDATA[<h1>{$title}</h1>]]></span>
        <![CDATA[<p>Content will go here</p>
    </body>
</html>]]></pre>
            </section>
            <section id="xquery_beyond">
                <h3>Beyond static HTML</h3>
                <p>The preceding examples use XQuery to create static HTML, and they have the
                    following limitations, which will address when we discuss <a href="#xinclude"
                        >XInclude</a> and <a href="#controller"><i>controller.xql</i></a> in the
                    following sections:</p>
                <ul>
                    <li>The XQuery has not been designed to not respond to user input. That is,
                        there is no way to call the same XQuery with different parameters in order
                        to receive different, customized output.</li>
                    <li>The page contains boilerplate that we will probably want to include in many
                        other pages. At the moment this might involve links to site-standard CSS or
                        JavaScript, but it could also involve HTML content snippets, such as
                        headers, footers, and menus.</li>
                    <li>The URL that retrieves this page is
                            <code>http://localhost:8080/exist/db/apps/myapp/modules/index.xql</code>
                        (where <i>myapps</i> is replaced by the name of the app). Where the user
                        links to the page explicitly, we would prefer a less cluttered and less
                        verbose URL.</li>
                    <li>Insofar as this is intended to be our default page, we would like the user
                        to be able to load it by navigating to the root of the app, e.g., without
                        specifying the <i>index.xql</i> filename.</li>
                </ul>
            </section>
        </section>
        <section id="xinclude">
            <h2>Modularize with XInclude</h2>
            <section id="xinclude_preliminaries">
                <h3>XInclude preliminaries in the context of eXist-db apps</h3>
                <p>By default eXist-db supports the inclusion of XML snippets inside another XML
                    document with <a href="https://www.w3.org/TR/xinclude-11/">XInclude</a>.
                    XInclude processing happens during serialization, that is, at the last stage
                    before eXist-db returns the results of an XQuery. For more information about
                    using XInclude inside eXist-db, see <a
                        href="https://exist-db.org/exist/apps/doc/xinclude"
                        >https://exist-db.org/exist/apps/doc/xinclude</a> and the <q>XInclude</q>
                    section of Chapter 10, <q>Other XML technoloogies</q>, of Erik Siegel and Adam
                    Retter’s <cite>eXist</cite>, Beijing et al.: O’Reilly, 2014, pp. 243–45.</p>
                <p>The following details govern the use of XInclude within eXist-db:</p>
                <ul>
                    <li>Includes are expressed with an empty <code>&lt;xi:include&gt;</code>
                        element, where the prefix <code>xi:</code> is bound to the namespace
                            <code>http://www.w3.org/ 2001/XInclude</code>, which must be
                        declared.</li>
                    <li>The document to be included is specified with an <code>@href</code>
                        attribute on the <code>&lt;xi:include></code> element. The value of the
                            <code>@href</code> attribute must be an absolute (not relative) path,
                        such as
                            <code>http://localhost:8080/exist/rest/db/apps/repertorium/includes/header.xql</code>
                        or <code>xmldb:exist:///db/apps/repertorium/includes/header.xql</code>. We
                        are actually going to use a third variant, but it depends on our having
                        configured <i>controller.xql</i>, so we’ll discuss it separately once we’ve
                        taken care of that configuration.</li>
                    <li>The target of the <code>@href</code> attribute must be well-formed XML.</li>
                    <li>It is possible to include either an entire XML document or a part of one.
                        The entire document is the default; parts may be specified by adding an
                            <code>@xpointer</code> attribute to the <code>&lt;xi:include&gt;</code>
                        element in one of two ways:<ul>
                            <li>An <code>@xpointer</code> attribute may point to an
                                    <code>@xml:id</code> attribute in the included document. For
                                example, <code>&lt;xi:include
                                    href="xmldb:exist:///db/apps/repertorium/includes/filename.xml
                                    xpointer="stuff"/&gt;</code> will include the element inside
                                    <i>filename.xml</i> that has an <code>@xml:id</code> value of
                                    <q>stuff</q>.</li>
                            <li>Alternatively the value of the <code>@xpointer</code> attribute may
                                be an XPath expression wrapped in <code>xpointer()</code>, which is
                                traversed within the target document. For example,
                                    <code>&lt;xi:include
                                    href="xmldb:exist:///db/apps/repertorium/includes/filename.xml
                                    xpointer="xpointer(//l)"/&gt;</code> returns all of the
                                    <code>&lt;l&gt;</code> elements in the target document.</li>
                        </ul></li>
                    <li>One powerful feature of XInclude within eXist-db is that if the value of the
                            <code>@href</code> attribute is an XQuery script, the XQuery will be
                        executed and its output will be included. Scripts specified in this way
                        automatically have access to the following information:<ul>
                            <li><code>$xinclude:current-doc</code>, when used inside the included
                                resource, points to the bare name of the master document. This makes
                                it possible for the included document to adjust its output according
                                to where it is being included. We use this in the Repertorium
                                project to customize the boilerplate header to include or exclude
                                particular buttons depending on the master document (discussed
                                below). There is also an <code>$xinclude:current-collection</code>
                                variable that points to the collection that contains the master
                                document.</li>
                            <li>It is possible to pass parameters to the included document as part
                                of a URL query string, e.g., <code>&lt;xi:include
                                    href="xmldb:exist:///db/apps/repertorium/includes/filename.xql?title=Hi"/></code>.
                                The included document must declare the parameter, along the lines of
                                    <code>declare variable $title external;</code>. If the parameter
                                value contains spaces or puncutation, it must be encoded as if it
                                were a URI, e.g., <code>&lt;xi:include
                                    href="xmldb:exist:///db/apps/repertorium/includes/filename.xql?title={encode-for-uri('Hi,
                                    Mom!')}"/&gt;</code>. We use this in the Repertorium project to
                                pass a customized, page-specific value for the
                                    <code>&lt;title></code> element of what would otherwise be a
                                boilerplate HTML <code>&lt;head></code>.</li>
                            <li>If the value of the <code>@href</code> attribute is an XQuery
                                script, and not an XML document, the <code>@xpointer</code>
                                attribute is ignored. That is, the <code>@xpointer</code> attribute
                                is meaningful only when the the target of the <code>@href</code>
                                attribute is an XML document, and not an XQuery script.</li>
                        </ul></li>
                </ul>
            </section>
            <section id="xinclude_header">
                <h3>Managing boilerplate information with XInclude</h3>
                <p>Since all of our app documents will use at least some of the same CSS and
                    JavaScript, we can move the <code>&lt;head&gt;</code> element, which contains
                    the <code>&lt;link&gt;</code> and <code>&lt;script&gt;</code> elements, into a
                    separate included resource. Since the title will vary with different master
                    documents, we can pass it as a parameter. Our <i>index.xql</i> now looks like
                    the following:</p>
                <pre><![CDATA[xquery version "3.1";
declare default function namespace "http://www.w3.org/2005/xpath-functions";
declare default element namespace "http://www.w3.org/1999/xhtml";
declare namespace xi="http://www.w3.org/2001/XInclude";
declare namespace output = "http://www.w3.org/2010/xslt-xquery-serialization";
declare option output:method "xml";
declare option output:media-type "application/xhtml+xml";
declare option output:omit-xml-declaration "no";
declare option output:indent "no";
declare variable $title as xs:string := "My awesome eXist-db app";
<html xmlns="http://www.w3.org/1999/xhtml">]]>
    <span class="pre-highlight"><![CDATA[<xi:include href="xmldb:exist:///db/apps/repertorium/includes/header.xql?title={encode-for-uri($title)}"/>]]></span>
    <![CDATA[<body>
        <h1>{$title}</h1>
        <p>Content will go here</p>
    </body>
</html>]]></pre>
                <p>and the new included resource looks like:</p>
                <pre><![CDATA[xquery version "3.1";
declare variable $title external;
<head xmlns="http://www.w3.org/1999/xhtml">
    <title>{$title}</title>
    <link rel="stylesheet" type="text/css" href="../resources/css/style.css"/>
    <script type="text/javascript" src="../resources/js/greet.js"></script>
</head>]]></pre>
                <p>The content of the <code>&lt;head&gt;</code> element is the same, but it is now
                    located inside the included <i>header.xql</i> script, instead of directly inside
                        <i>index.xql</i>.</p>
                <p>This point of this strategy is that we assume that all files will have
                    essentially the same <code>&lt;head&gt;</code> element, except for the
                        <code>&lt;title&gt;</code>. If we put the <code>&lt;head&gt;</code> into an
                    included resource, should we later need to modify it, we can modify it in just
                    one place and the changes will be reflected in all pages that include it. We
                    deal with the difference in titles by passing the value into the included
                    resource as a parameter, where it is interpreted before rendering. We use the
                        <code>encode-for-uri()</code> function, introduced above, because titles may
                    contain spaces or punctuation, which cannot otherwise be passed from the master
                    XQuery to the included one. Below we’ll modify the path to the included resource
                    to simplify it by removing the dependency on installation inside
                    <i>/db/apps</i>.</p>
            </section>
        </section>
        <section id="controller">
            <h2>Configure <i>controller.xql</i></h2>
            <section id="controller_preliminaries">
                <h3>What to expect from <i>controller.xql</i></h3>
                <p>If an app contains a <i>controller.xql</i> script in its root collection, eXist
                    automatically passes all HTTP requests to the controller. The controller can
                    rewrite the request, by, for example, routing it to a specific XQuery script, or
                    it can pass it along unchanged to be handled normally. This tutorial does not
                    include a beginner’s introduction to controller configuration, and <strong>new
                        developers must pause at this point and read <a
                            href="http://exist-db.org/exist/apps/doc/urlrewrite"
                            >http://exist-db.org/exist/apps/doc/urlrewrite</a> and Chapter 9,
                            <q>Building applications</q>, of Erik Siegel and Adam Retter’s
                            <cite>eXist</cite>, Beijing et al.: O’Reilly, 2014, pp.
                    191–235</strong>. Understanding the examples below requires a basic familiarity
                    with query handling and the eXist-db <i>controller.xql</i> file, as provided at
                    these links. We also recommend, as an example, Joe Wicentowski’s <cite><a
                            href="https://github.com/joewiz/punch">Punch</a></cite>, a tutorial
                    project that uses a clearly commented <i>controller.xql</i> to illustrate query
                    rewriting within an eXist-db app. Our project will contain exactly one
                        <i>controller.xql</i> resource, which will be located inside the app root
                    collection.</p>
            </section>
            <section id="controller_skeleton">
                <h3>Create a skeletal <i>controller.xql</i> skeleton</h3>
                <p>Start by creating a skeletal <i>controller.xql</i> script in the root collection
                    of your application with the following contents (copied, with minor
                    modifications, from Erik Siegel and Adam Retter’s <cite>eXist</cite>, Beijing et
                    al.: O’Reilly, 2014, p. 196):</p>
                <pre>xquery version "3.1" encoding "UTF-8";

(: External variables available to the controller: 
$exist:path
    The part of the URL after the part that led to the controller. For example:
    /a/b/c.xq
$exist:resource
    The part of the URL after the last / character, usually pointing to a 
    resource. For example: c.xq
$exist:controller
    The part of the URL leading from the prefix (typically /apps) to the controller 
    script. For example, the name of the root collection of your app, for example:
    /repertorium
$exist:root
    The path to where the app is installed, typically xmldb:exist:///db/apps.
:)
declare variable $exist:path external;
declare variable $exist:resource external;
declare variable $exist:controller external;
declare variable $exist:root external;

(: Other variables :)
declare variable $home-page-url := "index";

(: Function to get the extension of a filename: :)
declare function local:get-extension($filename as xs:string) as xs:string {
    let $name := replace($filename, ".*[/\\]([^/\\]+)$", "$1")
    return
        if (contains($name, "."))
        then
            replace($name, ".*\.([^\.]+)$", "$1")
        else
            ""
};

(: If there is no resource specified, go to the home page.
This is a redirect, forcing the browser to perform a redirect. So this request
will pass through the controller again... :)
if ($exist:resource eq "") then
    &lt;dispatch xmlns="http://exist.sourceforge.net/NS/exist">
        &lt;redirect url="{$home-page-url}"/>
    &lt;/dispatch>
    
(: Check if there is no extension. If not, assume it is an XQuery script and forward
to the actual XQuery script by inserting the "modules/" step to the subcollection and
adding the ".xql" extension. Because we use forward here, the browser will not be 
informed of the change and the user will see a URL without the "modules/" step in the
path and without the ".xql" extension. :)
else
    if (local:get-extension($exist:resource) eq "") then
        &lt;dispatch xmlns="http://exist.sourceforge.net/NS/exist">
            &lt;forward url="{concat(
                $exist:controller, 
                substring-before($exist:path, $exist:resource), 
                "modules/", 
                $exist:resource, ".xql"
            )}"/>
        &lt;/dispatch>
        (: Anything else, pass through: :)
    else
        &lt;ignore xmlns="http://exist.sourceforge.net/NS/exist">
            &lt;cache-control cache="yes"/>
        &lt;/ignore></pre>
                <p>If you navigate to <code>http://locahost:8080/exist/db/apps/repertorium/</code>
                    (replace <q>repertorium</q> with the name of your app), you should see the
                    output of executing the <i>index.xql</i> script that is in your <i>modules</i>
                    subcollection, and the URL will change to
                        <code>http://locahost:8080/exist/db/apps/repertorium/index</code>. But:</p>
                <ul>
                    <li>Your CSS and JavaScript links don’t work; you get the HTML, but not the
                        styling or JavaScript functionality.</li>
                    <li>You can also retrieve the main page by asking for
                            <code>http://locahost:8080/exist/db/apps/repertorium/index</code>.</li>
                    <li>Asking for
                            <code>http://locahost:8080/exist/db/apps/repertorium/modules/index.xql</code>,
                        which is where your XQuery actually resides, works, and includes the CSS and
                        JavaScript that don’t work (yet) with the rewriting.</li>
                    <li>Asking for
                            <code>http://locahost:8080/exist/db/apps/repertorium/index.xql</code>
                        (that is, omitting the <code>modules/</code> step but adding the
                            <code>.xql</code> extension), raises an error.</li>
                    <li>You need the trailing slash. This is the one limitation you cannot control
                        from within your app because without the slash, the URL never reaches your
                        controller.</li>
                </ul>
                <p>Except for the last point, we need to fix the controller to ensure that CSS and
                    JavaScript are processed properly, and that behavior is consistent with
                    reasonable user expectations. But first we need to understand how it works and
                    that understanding starts with eXist-db controller variables and the
                        <code>request:</code> module..</p>
            </section>
            <section id="controller_variables">
                <h3>System variables and <i>controller.xql</i></h3>
                <p>eXist-db automatically makes the following five system variables available within
                        <i>controller.xql</i>:</p>
                <ul>
                    <li><code>$exist:root</code> The part of the database URL the precedes the name
                        of the collection that contains the controller. In a standard installation
                        this location can be represented by either
                            <code>http://localhost:8080/exist/rest/db/apps</code> or
                            <code>xmldb:exist:///db/apps</code>.</li>
                    <li><code>$exist:prefix</code> The part of the URL that precedes the controller.
                        The default value is <code>/apps</code>.</li>
                    <li><code>$exist:controller</code> The part of the URL leading from the prefix
                        (typically <code>/apps</code>) to the collection that contains the
                        controller script, which in this case (and typically) is the root collection
                        of your app, for example: <code>/repertorium</code>.</li>
                    <li><code>$exist:path</code> The part of the URL after the part that led to the
                        controller. For example: <code>/index</code>.</li>
                    <li><code>$exist:resource</code> The part of the URL after the last
                            <code>/</code> character, which typically resolves to a resource after
                        query rewriting. For example: <code>index</code> (which in the Repertorium
                        resolves to <code>/modules/index.xql</code>). This value is null if the URL
                        ends in a slash, although the controller will still resolve it to a real
                        resource.</li>
                </ul>
                <p>The relationship among these variables and their relationships to URLS are
                    illustrated in the following table. Note that some variables contain other
                    variables within themselves:</p>
                <table>
                    <tr>
                        <th>Variable</th>
                        <th colspan="2"><code>$exist:root</code></th>
                        <th rowspan="2"><code>$exist:controller</code></th>
                        <th colspan="2"><code>$exist:path</code></th>
                    </tr>
                    <tr>
                        <th>Variable</th>
                        <th>[none]</th>
                        <th><code>$exist:prefix</code></th>
                        <th>[none]</th>
                        <th><code>$exist:resource</code></th>
                    </tr>
                    <tr>
                        <th>Value</th>
                        <td><code>xmldb:exist:///db</code></td>
                        <td><code>/apps</code></td>
                        <td><code>/repertorium</code></td>
                        <td><code>/</code></td>
                        <td><code>index</code></td>
                    </tr>
                </table>
                <p><code>$exist:prefix</code>, <code>$exist:controller</code>, and
                        <code>$exist:path</code> always begin with a slash;
                        <code>$exist:resource</code> never does. None of these variables ever ends
                    in a slash. This is important because we’re going to stitch some of them
                    together to form a new path, and we need to understand where we have to add
                    slashes and where they are already present.</p>
            </section>
            <section id="controller_request">
                <h3>The <code>request:</code> module and <i>controller.xql</i></h3>
                <p>In addition to the preceding five variables that are automatically available to
                    the controller, the eXist-db <code>request:</code> module provides two functions
                    that we use for query rewriting:</p>
                <ul>
                    <li><code>request:get-uri()</code> Return the URL before query rewriting, for
                        example, <code>/exist/apps/repertorium/index</code>.</li>
                    <li><code>request:get-context-path()</code> Returns the part of the URL that
                        precedes the prefix, typically <code>/exist</code>.</li>
                </ul>
                <p>We can use the variables described in the preceding section plus the functions
                    described here to construct a path to any location in our app. For example, a
                    path to <i>/exist/apps/repertorium/includes/header.xql</i> could be constructed
                    by concatenating variable and function values as follows:</p>
                <table>
                    <tr>
                        <th>Function or variable</th>
                        <th><code>request:get-context-path()</code></th>
                        <th><code>$exist:prefix</code></th>
                        <th><code>$exist:controller</code></th>
                        <th><code>[none]</code></th>
                    </tr>
                    <tr>
                        <th>Value</th>
                        <td><code>/exist</code></td>
                        <td><code>/apps</code></td>
                        <td><code>/repertorium</code></td>
                        <td><code>/includes/header.xql</code></td>
                    </tr>
                </table>
            </section>
            <section id="controller_example" style="display:flex; flex-direction: column;">
                <h3>Examining controller variables and <code>request:</code> function values</h3>
                <div>
                    <img src="exist-variables.png" alt="[Screen shot of eXist variables]"
                        style="float: right; max-width: 50%; min-width: 500px" />
                    <p>As described in the two immediately preceding sections, <i>controller.xql</i>
                        makes several system variables and other information available both for its
                        own use and to be passed to other XQuery scripts as parameters during query
                        rewriting. We use this facility in the Repertorium project to make it
                        possible for included resources that themselves have to point to other
                        resources (e.g., an XIncluded HTML <code>&lt;head&gt;</code> that links to
                        CSS and JavaScript resources) to construct absolute paths that point to
                        locations within the database. Note that because links to CSS and JavaScript
                        are resolved by the browser, which doesn’t know about
                            <code>xmldb:exist:///</code> URLs, those pointers must instead rely on
                        URLs that concatenate the value of <code>request:get-context-path()</code>
                        (typically <code>/exist</code>), the value of <code>$exist:prefix</code>
                        (typically <code>/apps</code>) and the value of
                            <code>$exist:controller</code> (typically the root collection of the
                        app, with a leading slash, e.g., <code>/repertorium</code>). The sample
                        output on the right displays the available variables and their values in the
                        context of the Repertorium project, which we have installed into
                            <code>xmldb:exist:///db/apps/repertorium</code>. We find this type of
                        table of controller variables a useful reference during development.</p>
                    <p>Using the variables in question in an app requires three steps:</p>
                    <ol>
                        <li>Using them to construct a rewritten path to the resource that should be
                            returned or otherwise processed;</li>
                        <li>Forwarding them from <i>controller.xql</i> as parameters to XQuery
                            scripts during query rewriting;</li>
                        <li>Retrieving and using them in those scripts.</li>
                    </ol>
                    <p>The last step may also entail forwarding them to included resources so that
                        they can be used to point to additional linked or included information. One
                        such use case, mentioned above, is that an HTML page may XInclude a
                            <code>&lt;head&gt;</code> element, which might itself need to point to
                        CSS or JavaScript resources.</p>
                    <p>The five variables that begin with <code>$exist:</code> are automatically
                        available within <i>controller.xql</i> (we declare them as
                            <code>external</code>), and we create the <code>$uri</code> and
                            <code>$context</code> variables within the controller by calling the
                        appropriate functions in the <code>request:</code> namespace (this strategy
                        is based on <a href="https://github.com/joewiz/punch"
                            >https://github.com/joewiz/punch</a>). The relevant parts of
                            <i>controller.xql</i> are:</p>
                </div>
                <pre>declare variable $exist:root external;
declare variable $exist:prefix external;
declare variable $exist:controller external;
declare variable $exist:path external;
declare variable $exist:resource external;

declare variable $uri as xs:anyURI := request:get-uri();
declare variable $context as xs:string := request:get-context-path();</pre>
                <p>We then forward those seven variables during rewriting with the following rewrite
                    rule inside <i>controller.xql</i> (which is based on a script at <a
                        href="https://github.com/eXist-book/book-code"
                        >https://github.com/eXist-book/book-code</a>). Our forwarding rule uses the
                        <code>&lt;add-parameter&gt;</code> element to forward all of our controller
                    variables to any receiving script (we discuss the forwarding process, including
                    construction of the forwarding <code>@url</code> value, later):</p>
                <pre><![CDATA[if (local:get-extension($exist:resource) eq "") then
    <dispatch xmlns="http://exist.sourceforge.net/NS/exist">
        <forward url="{concat(
            $exist:controller, 
            substring-before($exist:path, $exist:resource), 
            "modules/", 
            $exist:resource, 
            ".xql"
        )}">]]>
            <span class="pre-highlight"><![CDATA[<add-parameter name="exist:root" value="{$exist:root}"/>
            <add-parameter name="exist:prefix" value="{$exist:prefix}"/>
            <add-parameter name="exist:controller" value="{$exist:controller}"/>
            <add-parameter name="exist:path" value="{$exist:path}"/>
            <add-parameter name="exist:resource" value="{$exist:resource}"/>
            <add-parameter name="uri" value="{$uri}"/>
            <add-parameter name="context" value="{$context}"/>]]></span>
        <![CDATA[</forward>
    </dispatch>]]></pre>
                <p>The XQuery that generates the table at the top of this subsection, a resource
                    that we have called <i>test.xql</i>, is below. Inside <i>test.xql</i> we use
                        <code>request:get-parameter()</code> to retrieve the variables that are
                    passed in by <i>controller.xql</i>, and we concatenate three of them to create a
                    new variable, <code>$fqcontroller</code>, which we pass to our XIncluded
                        <i>header.xql</i> resource, which uses it to link to our CSS. We define
                        <code>$title</code> in each XQuery that constructs a page and pass it along
                    to the included header, since an HTML <code>&lt;title&gt;</code> element goes
                    inside <code>&lt;head&gt;</code>, which is what our <i>header.xql</i> creates.
                    In Real Life, an XQuery resource that is the target of query rewriting needs to
                    retrieve only those variables that it will use.</p>
                <pre><![CDATA[xquery version "3.1";
declare default function namespace "http://www.w3.org/2005/xpath-functions";
declare default element namespace "http://www.w3.org/1999/xhtml";
declare namespace xi = "http://www.w3.org/2001/XInclude";
declare namespace output = "http://www.w3.org/2010/xslt-xquery-serialization";
declare option output:method "xml";
declare option output:media-type "application/xhtml+xml";
declare option output:omit-xml-declaration "no";
declare option output:indent "no";
declare variable $title as xs:string := "eXist-db variables available to XQuery scripts";]]>
<span class="pre-highlight"><![CDATA[declare variable $exist:root as xs:string := request:get-parameter("exist:root", ());
declare variable $exist:prefix as xs:string := request:get-parameter("exist:prefix", ());
declare variable $exist:controller as xs:string := request:get-parameter("exist:controller", ());
declare variable $exist:path as xs:string := request:get-parameter("exist:path", ());
declare variable $exist:resource as xs:string := request:get-parameter("exist:resource", ());
declare variable $uri as xs:string := request:get-parameter("uri", ());
declare variable $context as xs:string := request:get-parameter("context", ());
declare variable $fqcontroller as xs:string := concat($context, $exist:prefix, $exist:controller, '/');]]></span>
<![CDATA[<html
    xmlns="http://www.w3.org/1999/xhtml">]]>
<span class="pre-highlight"><![CDATA[    <xi:include
        href="{
                concat(
                $exist:root,
                $exist:controller,
                '/includes/header.xql?title=',
                encode-for-uri($title),
                '&amp;fqcontroller=',
                $fqcontroller
                )
            }"/>]]></span>
<![CDATA[    <body>
        <h1>{$title}</h1>
        <table>
            <tr><th>Variable</th><th>Value</th></tr>
            <tr><td><code>$title</code></td><td>{$title}</td></tr>
            <tr><td><code>$exist:root</code></td><td>{$exist:root}</td></tr>
            <tr><td><code>$exist:prefix</code></td><td>{$exist:prefix}</td></tr>
            <tr><td><code>$exist:controller</code></td><td>{$exist:controller}</td></tr>
            <tr><td><code>$exist:path</code></td><td>{$exist:path}</td></tr>
            <tr><td><code>$exist:resource</code></td><td>{$exist:resource}</td></tr>
            <tr><td><code>$uri</code> (from <code>request:get-uri()</code>)</td><td>{$uri}</td></tr>
            <tr><td><code>$context</code> (from <code>request:get-context-path()</code>)</td><td>{$context}</td></tr>
            <tr>
                <td><code>$fqcontroller</code><br/>(<code>concat($context, $exist:prefix, $exist:controller, '/')</code>)</td>
                <td>{$fqcontroller}</td>
            </tr>
        </table>
    </body>
</html>]]></pre>
                <p><i>header.xql</i>, in turn, uses <code>$fqcontroller</code> as follows to
                    construct links to our CSS that can be resolved by the browser:</p>
                <pre><![CDATA[xquery version "3.1";
declare variable $title external;]]>
<span class="pre-highlight"><![CDATA[declare variable $fqcontroller external;]]></span>
<![CDATA[<head xmlns="http://www.w3.org/1999/xhtml">
    <title>{$title}</title>]]>
<span class="pre-highlight"><![CDATA[    <link rel="stylesheet" type="text/css" href="{concat($fqcontroller, 'resources/css/style.css')}"/> 
    <link rel="stylesheet" type="text/css" href="{concat($fqcontroller, 'resources/css/repertorium.css')}"/>]]></span>
<![CDATA[</head>]]></pre>
            </section>
            <section id="controller_skeleton_discussion">
                <h3>How <i>controller.xql</i> rewrites a query URL</h3>
                <p>Understanding the part of the controller that deals with XQuery files is the key
                    to understanding how XQuery rewriting is implemented in an app, so let’s look at
                    the most important part of it closely:</p>
                <pre><span class="pre-highlight">if (local:get-extension($exist:resource) eq "")</span> then
    &lt;dispatch xmlns="http://exist.sourceforge.net/NS/exist">
        &lt;forward url="{concat(
            <span class="pre-highlight">$exist:controller, 
            substring-before($exist:path, $exist:resource), 
            "modules/", 
            $exist:resource, 
            ".xql"</span>
        )}"/>
    &lt;/dispatch></pre>
                <p>Our <code>local:get-extension($exist:resource)</code> function retrieves the
                    extension from the <code>$exist:resource</code>, which, as noted above, is the
                    part of the original URL after the final slash. If <code>$exist:resource</code>
                    is not null (that is, if the original URL does not end in a slash, about which
                    see below), it may or may not have an extension. For example,
                        <code>index.xql</code> has the extension <i>.xql</i>; <code>index</code>
                    does not have an extension. If there is no extension, the
                        <code>local:get-extension()</code> function will return the empty string;
                    otherwise it will return the extension without the leading dot (for example,
                        <code>xql</code>).</p>
                <p>The <code>if</code> clause tests whether the original query has no extension
                    (such as when the user asks for
                        <code>http://locahost:8080/exist/db/apps/repertorium/index</code>, rather
                    than something ending in <code>index.xql</code>). We’ve decided that the
                    convention in our app will be that resources without extensions are XQuery
                    scripts, so we want the controller to forward the call to a modified URL, and
                    the modifications involve 1) looking in the <i>modules</i> subcollection and 2)
                    adding an <i>.xql</i> extension. The script builts up that modified URL by
                    concatenating the following values, in order:</p>
                <ul>
                    <li><code>$exist:controller</code> This is the location of <i>controller.xql</i>
                        file, which is the root collection of the app, starting with a slash, e.g.,
                            <code>/repertorium</code>. Our aggregated rewritten URL is now just
                            <code>/repertorium</code>.</li>
                    <li><code>substring-before($exist:path, $exist:resource)</code>.
                            <code>$exist:path</code> is the path from the location of the controller
                        to the end of the URL (minus any query string), which in the case of
                            <code>http://locahost:8080/exist/db/apps/repertorium/index</code>, is
                        just <code>/index</code>. <code>$exist:resource</code> is the part after the
                        final slash, which in this case is just <code>index</code>. This means that
                        our <code>substring-before()</code> function returns just a slash. When we
                        append the slash to our aggregated path, it is now equal to
                            <code>/repertorium/</code>.</li>
                    <li><code>modules/</code> Since our XQuery lives in a <i>modules</i>
                        subcollection that we don’t want the user to have to specify in the URL, we
                        add it during query rewriting. The aggregated URL now looks like
                            <code>/repertorium/modules/</code>.</li>
                    <li><code>$exist:resource</code> As mentioned above, this variable is the part
                        of the original URL after the final slash, which in this case was
                            <code>index</code>. When we add it, our aggregated URL looks like
                            <code>/repertorium/modules/index</code>.</li>
                    <li><code>.xql</code> Since our XQuery resources have <i>.xql</i> extensions, we
                        add that at the end of the rewritten URL, finally yielding
                            <code>/repertorium/modules/index.xql</code>.</li>
                </ul>
                <p>Since that final result is the actual path to our main page, the XQuery is
                    processed and the output is loaded into the browser. Because we used
                        <code>&lt;forward&gt;</code> (instead of <code>&lt;redirect&gt;</code>), the
                    browser address bar continues to display the URL without the modifications, even
                    though the browser uses those modifications to find and load the file.</p>
            </section>
            <section id="controller_includes">
                <h3>Fixing links to includes</h3>
                <p>As a general rule of thumb, wherever possible paths in an app should be absolute
                    (not relative), should not assume that apps are always installed under
                        <i>/db/apps</i>, and should use database URLs (beginning with
                        <i>xmldb:exist:///</i>) rather than HTTP URLs (beginning with
                        <i>http://localhost:8080/exist</i>). Absolute database URLs that do not make
                    unnecessary assumptions about paths are the most robust with respect to query
                    rewriting and the possible physical relocation of resources. When we first
                    constructed our <i>index.xql</i> file when introducing XInclude (see <a
                        href="#xinclude_header">Managing boilerplate information with XInclude</a>),
                    the link from <i>index.xql</i> to <i>header.xql</i>, which contained the HTML
                        <code>&lt;head&gt;</code> element, read
                        <code>href="xmldb:exist:///db/apps/repertorium/includes/header.xql?title={encode-for-uri($title)}</code>,
                    which will break if the app is installed into a non-standard location. Second,
                    the links to CSS and JavaScript in <i>header.xql</i>, introduced in the same
                    section of this tutorial, used relative paths (e.g.,
                        <code>href="../resources/css/style.css"</code>), and those <em>did</em>
                    break as soon as we rewrote our query. The reason the links broke is that the
                    path is traversed from the original URL, without the <i>/modules</i> step, so
                    instead of climbing out of <i>modules</i> and then down into <i>resources</i>,
                    it climbs out of <i>repertorium</i> and then fails to find a <i>resources</i>
                    child collection for the next path step.</p>
                <p>To fix the broken or fragile links and make our code generally more robust we
                    needed to change both the <i>index.xql</i> master document and the
                        <i>header.xql</i> included document to use controller variables and
                        <code>request:</code> functions to construct absolute paths. We also needed
                    to change <i>controller.xql</i> to make those variables available to
                        <i>index.xql</i> and <i>header.xql</i>. In the example at <a
                        href="#controller_skeleton_discussion">How <i>controller.xql</i> rewrites a
                        query URL</a>, we used the variables to construct the rewritten URL, and in
                    the more complete controller example in <a href="#controller_example">Examining
                        controller variables and <code>request:</code> function values</a>, we used
                        <code>&lt;add-parameter&gt;</code> to forward the variables during rewriting
                    so that they can be reused when the script for the page is processed and
                    rendered. The forwarding instruction with the parameters looks like:</p>
                <pre><![CDATA[if (local:get-extension($exist:resource) eq "") then
    <dispatch xmlns="http://exist.sourceforge.net/NS/exist">
        <forward url="{concat(
            $exist:controller, 
            substring-before($exist:path, $exist:resource), 
            "modules/", 
            $exist:resource, 
            ".xql"
        )}">
            <add-parameter name="exist:root" value="{$exist:root}"/>
            <add-parameter name="exist:prefix" value="{$exist:prefix}"/>
            <add-parameter name="exist:controller" value="{$exist:controller}"/>
            <add-parameter name="exist:path" value="{$exist:path}"/>
            <add-parameter name="exist:resource" value="{$exist:resource}"/>
            <add-parameter name="uri" value="{$uri}"/>
            <add-parameter name="context" value="{$context}"/>
        </forward>
    </dispatch>]]></pre>
                <p>If, for example, the original URL was
                        <code>http://localhost:8080/exist/db/apps/repertorium/index</code>, the
                    forwarding instruction rewrites the URl as
                        <code>xmldb:exist:///db/apps/repertorium/modules/index.xql</code>, and it
                    makes the seven parameters available from within that script.</p>
                <p>The example in <a href="#controller_example">Examining controller variables and
                            <code>request:</code> function values</a>, above, showed that the
                    variables can be retrieved with the <code>request:get-parameter()</code>
                    function. They can be used to construct a path to an XIncluded
                    <i>header.xql</i>, and the XInclude instruction can also pass the variables into
                    the <i>header.xql</i> script, so that they can be used there to construct
                    absolute paths to the CSS and JavaScript resources. Since we don’t need all of
                    the variables down the pipeline, we retrieve and forward only the ones we use,
                    the <code>$title</code> and the <code>$fqcontroller</code> that we constructed
                    by concatenation. The <i>index.xql</i> page might look like the following:</p>
                <pre>
xquery version "3.1";
declare default function namespace "http://www.w3.org/2005/xpath-functions";
declare default element namespace "http://www.w3.org/1999/xhtml";
declare namespace xi="http://www.w3.org/2001/XInclude";
declare namespace output = "http://www.w3.org/2010/xslt-xquery-serialization";
declare option output:method "xml";
declare option output:media-type "application/xhtml+xml";
declare option output:omit-xml-declaration "no";
declare option output:indent "no";
declare variable $title as xs:string := "Repertorium of Old Bulgarian Literature and Letters";
declare variable $exist:root as xs:string := request:get-parameter("exist:root", ());
declare variable $exist:prefix as xs:string := request:get-parameter("exist:prefix", ());
declare variable $exist:controller as xs:string := request:get-parameter("exist:controller", ());
declare variable $context as xs:string := request:get-parameter("context", ());
declare variable $fqcontroller as xs:string := concat($context, $exist:prefix, $exist:controller, '/');
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
    &lt;xi:include href="{concat(
        $exist:root, 
        $exist:controller, 
        '/includes/header.xql?title=', 
        encode-for-uri($title),
        '&amp;fqcontroller=',
        $fqcontroller
    )}"/&gt;
    &lt;body&gt;
        &lt;h1&gt;{$title}&lt;/h1&gt;
        &lt;p&gt;Content will go here&lt;/p&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre>
                <p>The link to <i>header.xql</i> is formed by concatenating, in order:</p>
                <ol>
                    <li><code>$exist:root</code> At this point the URL is equal to
                            <code>xmldb:exist:///db/apps</code>. If for any reason we have installed
                        our app into a different location, that different location will nonetheless
                        be reported correctly because eXist-db is reading the actual location,
                        instead of just assuming that it will be the standard one. And because we
                        don’t have an HTTP path (one that starts with something like
                            <code>http://localhost:8080</code>), eXist-db will not make unnecessary
                        and possibly incorrect assumptions about the port on which eXist-db is
                        running.</li>
                    <li><code>$exist:controller</code> The path is now equal to
                            <code>xmldb:exist:///db/apps/repertorium</code></li>
                    <li><code>/includes/header.xql</code> This takes us to the location of include
                        files in our app. The path is now equal to
                            <code>xmldb:exist:///db/apps/repertorium/includes/header.xql</code>.</li>
                    <li>We then add a query string to pass parameters from <i>index.xql</i> into
                            <i>header.xql</i>, leading to a final URL of
                            <code>xmldb:exist:///db/apps/repertorium/includes/header.xql?title=X&amp;exist:controller=/repertorium&amp;exist:root=xmldb:exist///db/apps</code>,
                        where <code>X</code> stands for the URL-encoded value of the title. We need
                        to encode the title because it may contain characters not permitted in URLs,
                        such as spaces. We are not URL-encoding the controller variables, which is
                        safe only as long as our resource names in the database do not contain those
                        same characters.</li>
                </ol>
                <!--TODO: Is colon okay in query parameter name, URL-encoded or bare? See eXist book,
                    p. 92.-->
            </section>
            <section id="controller_css">
                <h3>Linking to CSS and JavaScript</h3>
                <p>Finally, once we have passed the parameters into <i>header.xql</i>, our included
                    document, we can use them to construct an absolute path from there to our CSS
                    and JavaScript resources. This is illustrated at the end of <a
                        href="#controller_example">Examining controller variables and
                            <code>request:</code> function values</a>, above, repeated here:</p>
                <pre><![CDATA[xquery version "3.1";
declare variable $title external;
declare variable $fqcontroller external;
<head xmlns="http://www.w3.org/1999/xhtml">
    <title>{$title}</title>
    <link rel="stylesheet" type="text/css" href="{concat($fqcontroller, 'resources/css/style.css')}"/> 
    <link rel="stylesheet" type="text/css" href="{concat($fqcontroller, 'resources/css/repertorium.css')}"/>
</head>]]></pre>
                <p>The constructed links to the CSS in our example look like
                        <code>href="/exist/apps/repertorium/resources/css/style.css"</code>. Links
                    to JavaScript would be constructed similarly.</p>
            </section>
            <section id="controller_home">
                <h3>The main page</h3>
                <p>The main page in our app is <i>index.xql</i>, which can be retrieved with
                        <code>http://localhost:8080/exist/apps/repertorium/index</code>, but we
                    would like it to be the default when no page is specified, that is, when the
                    user enters just <code>http://localhost:8080/exist/apps/repertorium/</code>. We
                    handle this inside the controller by testing whether
                        <code>$exist:resource</code> is non-null, that is, whether there is anything
                    after the final slash in the URL. If not, the controller forwards the URL to the
                    designated main page:</p>
                <pre>declare variable $home-page-url as xs:string := "index";
                    
if ($exist:resource eq "") then
    &lt;dispatch xmlns="http://exist.sourceforge.net/NS/exist"&gt;
        &lt;redirect url="{$home-page-url}"/&gt;
    &lt;/dispatch&gt;</pre>
                <p>Because this is a redirect, and not a forward, the controller rewrites the URL as
                    if <code>$exist:resource</code> had been specified as <code>index</code> and
                    then sends it through the controller again.</p>
                <p>One limitation to configuring a default page is that the trailing slash must be
                    present, so if the user enters
                        <code>http://localhost:8080/exist/apps/repertorium</code>, without the final
                    slash, the main page will not be loaded. This behavior cannot be controlled by
                    the app controller because the app controller never sees the URL, and it gets
                    handled at a higher level in the database hierarchy. If you have control of your
                    entire eXist-db instance, you can set a forwarding instruction outside the app
                    to handle this contingency.</p>
            </section>
            <section id="controller_extensions">
                <h3>Documents with extensions</h3>
                <section id="controller_extensions_xql">
                    <h4>The <i>.xql</i> extension</h4>
                    <p>The controller example above assumes that URLs that end in resources without
                        explicit extensions are XQuery scripts, and it rewrites the URLs
                        accordingly. If the user specifies the <i>.xql</i> extension, the URL will
                        not be rewritten (see below), so a path like
                            <code>http://localhost:8080/exist/apps/repertorium/index.xql</code> will
                        raise an error. If you are concerned about users entering URLs of this sort,
                        it is possible to add an additional test condition in the controller to
                        handle it, but we have not done that in the present example.</p>
                </section>
                <section id="controller_extensions_other">
                    <h4>Other extensions</h4>
                    <p>We assume that all resources with extensions should be passed through without
                        rewriting. This includes primarily resources in the <i>resources</i>
                        subcollection, such as images and CSS.</p>
                </section>
            </section>
            <section id="controller_conclusion">
                <h3>Controller summary</h3>
                <p>The controller configuration described above handles XQuery scripts specified
                    with a simplified path (no explicit references to the <i>modules</i>
                    subcollection) and without an <i>.xql</i> extension. It also handles static
                    resources, such as images and CSS, as it defaults to the specified main page
                    when no resource is named in the URL. It uses controller variables and the
                    functions from the <code>request:</code> module to support XIncludes with
                    absolute paths, as well as absolute paths for linking to CSS and JavaScript. And
                    because we use XQuery to construct our HTML output and our included header, we
                    can customize the <code>&lt;title&gt;</code> (rendered in the browser tab) and
                    other boilerplate details dynamically.</p>
            </section>
        </section>
        <section id="xslt">
            <h2>Using XSLT to transform XQuery results to HTML</h2>
        </section>
        <section id="generate">
            <h2>Generate your app</h2>
            <ol>
                <li>Verify that the owner and group of every collection and file are the owner and
                    group ids that you created originally in the eXide app wizard. Verify also that
                    the resource permissions are correct: anything users should be able to read
                    directly must be world-readable, and any XQuery that users should be able to run
                    should be world-executable. The easiest way to set these properties for multiple
                    resources simultaneously is to use <code>sm:chown()</code> and
                        <code>sm:chmod()</code> inside an XQuery <code>for</code> loop.</li>
                <li>To generate your app, open any file from within the app hierarchy in eXide. Then
                    go to Application → Download app. An <i>.xar</i> file will be downloaded into
                    the file system on the server where eXist-db is running.</li>
            </ol>
            <p>We also recommend using Application → Synchronize within eXide to export your app to
                a GitHub repo on your local filesystem. Although the instruction is called
                    <q>synchronize</q>, it only downloads from eXist-db to the file system. Since
                changes made directly on the filesystem are not uploaded during synchronization, our
                preferred strategy is to work entirely within the app inside eXist-db, and to run a
                sequence of synchronize (from within eXide) and then add, commit, and push (from the
                command line), as with a normal Git repo.</p>
        </section>
        <hr />
    </body>
</html>
