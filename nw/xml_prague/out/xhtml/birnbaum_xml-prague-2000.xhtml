<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Sequence alignment in XSLT 3.0</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.2"/><meta name="description" content="The Needleman Wunsch algorithm, which this year celebrates its quinquagenary anniversary, has been proven to produce an optimal global pairwise sequence alignment. Because this dynamic programming algorithm requires the updating of variables, it has posed challenges for functional programming paradigms like the one underlying XSLT. The present report explores these challenges and provides an implementation of the Needleman Wunsch algorithm in XSLT 3.0."/><meta name="keywords" content="sequence alignment, xslt"/></head><body><div xml:lang="en" class="article"><div class="titlepage"><div><div><h2 class="title"><a id="d5e1"/>Sequence alignment in XSLT 3.0</h2></div><div><div class="author"><h3 class="author"><span class="firstname">David</span> <span class="othername">J.</span> <span class="surname">Birnbaum</span></h3><div class="affiliation"><span class="jobtitle">Professor<br/></span><span class="orgname">Department of Slavic Languages and Literatures, University of Pittsburgh
                    (US)<br/></span></div><code class="email">&lt;<a class="email" href="mailto:djbpitt@gmail.com">djbpitt@gmail.com</a>&gt;</code></div></div><div><div class="abstract"><p class="title"><strong>Abstract</strong></p><p>The Needleman Wunsch algorithm, which this year celebrates its quinquagenary
                anniversary, has been proven to produce an optimal global pairwise sequence
                alignment. Because this dynamic programming algorithm requires the updating of
                variables, it has posed challenges for functional programming paradigms like the one
                underlying XSLT. The present report explores these challenges and provides an
                implementation of the Needleman Wunsch algorithm in XSLT 3.0.</p></div></div></div><hr/></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="#d5e23">Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e25">Why sequence aligment matters</a></span></dt><dt><span class="section"><a href="#d5e35">Biological and textual alignment</a></span></dt><dt><span class="section"><a href="#d5e45">Global pairwise alignment</a></span></dt><dt><span class="section"><a href="#d5e66">Overview of this report</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e84">About sequence alignment</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e86">Alignments and scoring</a></span></dt><dt><span class="section"><a href="#d5e141">Sequence alignment algorithms</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e149">Dynamic programming and the Needleman Wunsch algorithm</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e151">Dynamic programming</a></span></dt><dt><span class="section"><a href="#d5e162">The Needleman Wunsch algorithm</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e326">The challenges of dynamic programming and XSLT</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e338">Why recursion breaks</a></span></dt><dt><span class="section"><a href="#d5e350">Iteration to the rescue</a></span></dt><dt><span class="section"><a href="#d5e360">Processing the diagonal</a></span></dt><dt><span class="section"><a href="#d5e411">Save yourself a trip … and some space</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e415">Conclusions</a></span></dt><dt><span class="bibliography"><a href="#d5e431">Works cited</a></span></dt><dt><span class="appendix"><a href="#d5e510">A. Modeling alignment as table and graph</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e23"/>Introduction</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d5e25"/>Why sequence aligment matters</h3></div></div></div><p>Sequence alignment is a way of identifying and modeling similarities and
                differences in sequences of items, and has proven insightful and productive in both
                the natural sciences (especially in biology and medicine, where it is applied to
                genetic sequences) and the humanities (especially in text-critical scholarship,
                where it is applied to sequences of words in variant versions of a text). In textual
                scholarship, which is the domain in which the present report was developed, sequence
                alignment assists the philologist in identifying locations where manuscript
                witnesses agree and where they disagree.<a href="#ftn.d5e28" class="footnote" id="d5e28"><sup class="footnote">[1]</sup></a> These moments of agreement and disagreement, in turn, provide evidence
                about probable (or, at least, candidate) moments of shared transmission between
                textual witnesses, and thus serve as evidence to construct and support a
                philological argument about the history of a text.<a href="#ftn.d5e32" class="footnote" id="d5e32"><sup class="footnote">[2]</sup></a></p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d5e35"/>Biological and textual alignment</h3></div></div></div><p>Insofar as biomedical research enjoys a larger scientific community and richer
                funding resources than textual humanities scholarship, it is not surprising that the
                literature about sequence alignment, and the science reported in that literature, is
                quantitatively greater in the natural sciences than in the humanities. Furthermore,
                insofar as all sequence alignment is similar in certain mathematical ways, it is
                both necessary and appropriate for textual scholars to seek opportunities to adapt
                biomedical methods for their own purposes. For those reasons, the present report,
                although motivated by text-critical research, focuses on a method first proposed in
                a biological context and later also applied in philology.</p><p>This report does not take account of differences in the size and scale of
                biological and philological data, but it is nonetheless the case that alignment
                problems in biomedical contexts, on the one hand, and in textual contexts, on the
                other, typically differ at least in the following ways: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Genetic alignment may operate at sequence lengths involving entire
                            chromosomes or entire genomes, which are orders of magnitude larger than
                            the largest real-world textual alignment task.</p></li><li class="listitem"><p>Genetic alignment operates with a vocabulary of four words (nucleotide
                            bases), while textual alignment often involves a vocabulary of hundreds
                            or thousands of different words.</p></li></ul></div><p>The preceding systematic differences in size and scale invite questions about
                whether the different shape of the source data in the two domains might invite
                different methods. Especially in the case of heuristic approaches that are not
                guaranteed to produce an optimal solution, is it possible that compromises required
                to make data at large scale computationally tractable might profitably be avoided in
                domains involving data at a substantially smaller scale? Although the present report
                does not engage with this question, it remains part of the context within which
                solutions to alignment tasks in different disciplines ultimately should be
                assessed.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d5e45"/>Global pairwise alignment</h3></div></div></div><p>The following two distinctions—not between biological and textual alignment, but
                within both domains—are also relevant:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Both genetic and textual alignment tasks can be divided into
                                <span class="emphasis"><em>global</em></span> and <span class="emphasis"><em>local</em></span>
                            alignment. The goal of global alignment is to find the best alignment of
                                <span class="emphasis"><em>all items in the entire sequences</em></span>. In textual
                            scholarship this is often called <span class="emphasis"><em>collation</em></span> (cf.
                            e.g., <a class="xref" href="#fv_reader">Frankenstein variorum reader</a>). The goal of local alignment is to
                            find moments where <span class="emphasis"><em>subsequences</em></span> correspond, without
                            attempting to optimize the alignment of the entire sequences. A common
                            textual use for local alignment is <span class="emphasis"><em>text reuse</em></span>,
                            e.g., finding moments where Dante quotes or paraphrases Ovid (cf. <a class="xref" href="#peteghhem_2015">Van Peteghem 2015</a>, <a class="xref" href="#intertextual_dante">Intertextual Dante</a>).</p></li><li class="listitem"><p>Both genetic and textual alignment tasks may involve
                                <span class="emphasis"><em>pairwise alignment</em></span> or <span class="emphasis"><em>multiple
                                alignment</em></span>. Pairwise alignment refers to the alignment of
                            two sequences; multiple alignment refers to the alignment of more than
                            two sequences. In textual scholarship multiple alignment is often called
                                <span class="emphasis"><em>multiple-witness alignment</em></span>.</p></li></ul></div><p>The Needleman Wunsch algorithm described and implemented below has been proven to
                identify all optimal global pairwise alignments of two sequences, and it is
                especially well suited to alignment tasks where the two texts are of comparable size
                and are substantially similar to each other. The present report does not address
                either local alignment or multiple (witness) alignment.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d5e66"/>Overview of this report</h3></div></div></div><p>This report begins by introducing the use of dynamic programming methods in the
                Needleman Wunsch algorithm to identify all optimal global alignments of two
                sequences. It then identifies challenges to implementing this algorithm in XSLT and
                discusses those challenges in the context of developing such an implementation. All
                original code discussed in this report is available at <a class="link" href="https://github.com/djbpitt/xstuff/tree/master/nw" target="_top">https://github.com/djbpitt/xstuff/tree/master/nw</a>.</p><p>It should be noted that the goal of this report, and the code it contains, is to
                explore global pairwise sequence alignment in an XSLT environment. For that reason,
                it is not intended that this code function as a stand-alone end-user textual
                collation tool. There are two reasons for specifying the goals and non-goals of the
                present report in this way: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Textual collation as a philological method involves more than just
                            alignment. For example, the Gothenburg model of textual collation, which
                            has been implemented in the CollateX [<a class="xref" href="#collatex">CollateX</a>] and
                            Juxta [<a class="xref" href="#juxta">Juxta</a>] tools, expresses the collation process
                            as a five-step pipeline, within which alignment serves as the third step.<a href="#ftn.d5e76" class="footnote" id="d5e76"><sup class="footnote">[3]</sup></a></p></li><li class="listitem"><p>Real-world textual alignment tasks often involve more than two
                            witnesses, that is, they involve multiple-witness, rather than pairwise,
                            alignment. While some approaches to multiple-witness alignment are
                            implemented as a progressive or iterative application of pairwise
                            alignment, these methods are subject to order effects. Ultimately,
                            multiple-witness alignment is an NP hard problem with which the present
                            report does not seek to engage.<a href="#ftn.d5e81" class="footnote" id="d5e81"><sup class="footnote">[4]</sup></a></p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e84"/>About sequence alignment</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d5e86"/>Alignments and scoring</h3></div></div></div><p>An optimal alignment can be defined as an alignment that yields the best
                    <span class="emphasis"><em>score</em></span>, where the researcher is responsible for identifying
                an appropriate scoring method. Relationships involving individual aligned items from
                a sequence can be categorized as belonging to three possible types for scoring purposes:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Items from both sequences are aligned and are the same. This is called
                            a <span class="emphasis"><em>match</em></span>. If the two entire sequences are identical,
                            all item-level alignments are matches.</p></li><li class="listitem"><p>Items from both sequences are aligned but are different. This is
                            called a <span class="emphasis"><em>mismatch</em></span>. Mismatches may arise in
                            situations where they are sandwiched between matches. For example, given
                            the input sequences <span class="quote">“<span class="quote">The brown koala</span>”</span> and <span class="quote">“<span class="quote">The gray
                                koala</span>”</span>, after aligning the words <span class="quote">“<span class="quote">The</span>”</span> and
                                <span class="quote">“<span class="quote">koala</span>”</span> in the two sequences (both alignments are
                            matches), the color words sandwiched between them form an aligned
                            mismatch.</p></li><li class="listitem"><p>An item in one sequence has no corresponding item in the other
                            sequence. This is called a <span class="emphasis"><em>gap</em></span> or an
                                <span class="emphasis"><em>indel</em></span> (a correspondence of an item to no item
                            that can be interpreted as either an <span class="emphasis"><em>in</em></span>sertion in
                            one sequence or a <span class="emphasis"><em>del</em></span>etion from the other). Gaps
                            are inevitable where the sequences are of different lengths, so that,
                            for example. given <span class="quote">“<span class="quote">The gray koala</span>”</span> and <span class="quote">“<span class="quote">The
                                koala</span>”</span>, the item <span class="quote">“<span class="quote">gray</span>”</span> in the first sequence
                            corresponds to a gap in the second. Gaps may also occur with sequences
                            of the same length; for example, if we align <span class="quote">“<span class="quote">The brown koala
                                lives in Australia</span>”</span> with <span class="quote">“<span class="quote">The koala lives in South
                                Australia</span>”</span>, both sequences contain six words, but the most
                            natural alignment, with a length of seven items and one gap in each
                            sequence, is: </p><div class="table"><a id="d5e112"/><p class="title"><strong>Table 1. Alignment example with gaps</strong></p><div class="table-contents"><table class="table" summary="Alignment example with gaps" border="1"><colgroup><col/><col/><col/><col/><col/><col/><col/></colgroup><tbody><tr><td>The</td><td>brown</td><td>koala</td><td>lives</td><td>in</td><td> </td><td>Australia</td></tr><tr><td>The</td><td> </td><td>koala</td><td>lives</td><td>in</td><td>South</td><td>Australia</td></tr></tbody></table></div></div><p><br class="table-break"/>
                        </p></li></ul></div><p>A common scoring method is to assign a value of <span class="quote">“<span class="quote">1</span>”</span> to matches,
                    <span class="quote">“<span class="quote">-1</span>”</span> to mismatches, and <span class="quote">“<span class="quote">-1</span>”</span> to gaps. These values
                prefer alignments with as many matches as possible, and with as few mismatches and
                gaps as possible. But other scoring methods might, for example, assign a greater
                penalty to gaps than to mismatches, or might assign greater penalties to new gaps
                than to continuations of existing gaps (this is called an
                    <span class="emphasis"><em>affine</em></span> gap penalty).</p><p>The scoring method determines what will be identified as an optimal alignment for
                a circular reason: optimal in this context is defined as the alignment with the best
                score. This means that selection of an appropriate scoring method during
                philological alignment should reflect the researcher’s theory of the types of
                correspondences and non-correspondences that are meaningful for identifying textual
                moments to be compared. In the examples below we have assigned a score of
                    <span class="quote">“<span class="quote">1</span>”</span> for matches, <span class="quote">“<span class="quote">-1</span>”</span> for mistmatches, and
                    <span class="quote">“<span class="quote">-2</span>”</span> for gaps. This scoring system prefers mismatches to gaps, and
                scores gaps in a linear (not affine) way.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d5e141"/>Sequence alignment algorithms</h3></div></div></div><p>A naïve, brute-force approach to sequence alignment would construct all possible
                alignments, score them, and select the ones with the best scores. This method has
                exponential complexity, and therefore is not realistic even for relatively small
                real-world alignment tasks. Alternatives must therefore reduce the computational
                complexity, ideally by reducing the search space to exclude from consideration in
                advance all alignments that <span class="emphasis"><em>cannot</em></span> be optimal. Where this is
                not possible, a <span class="emphasis"><em>heuristic</em></span> method excludes from consideration in
                advance alignments that <span class="emphasis"><em>are unlikely to be</em></span> optimal. Heuristic
                methods entail a risk of inadvertently excluding an optimal alignment, but in the
                case of some computationally complex problems, a heuristic approach may be the only
                realistic way of reducing the complexity sufficiently to make the problem
                tractable.</p><p>In the case of global pairwise alignment, the Needleman Wunsch algorithm,
                described below, has been proven always to produce an optimal alignment, according
                to whatever definition of optimal the chosen scoring method instantiates. Needleman
                Wunsch is an implementation of <span class="emphasis"><em>dynamic programming</em></span>, and in the
                following two sections we first describe dynamic programming as a paradigm and then
                explain how it is employed in the Needleman Wunsch algorithm. These explanations are
                preparatory to describing the complications that dynamic programming, both in
                general and in the context of Needleman Wunsch, pose for XSLT and how they can be
                resolved.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e149"/>Dynamic programming and the Needleman Wunsch algorithm</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d5e151"/>Dynamic programming</h3></div></div></div><p>Dynamic programming, a paradigm developed by Richard Bellman at the Rand
                Corporation in the early 1950s, makes it possible to express complex coding tasks as
                a combination of smaller, more tractable, overlapping ones.<a href="#ftn.d5e154" class="footnote" id="d5e154"><sup class="footnote">[5]</sup></a> A commonly cited example of a task that is amenable to dynamic
                programming is the computation of a Fibonacci number. Insofar as every Fibonacci
                number beyond the first two can be expressed as a function of the two immediately
                preceding Fibonacci numbers, a naïve top-down approach would compute the two
                preceding values. This requires computing all of their preceding values, which
                requires computing their preceding values, etc., which ultimately leads to computing
                the same values repeatedly. A dynamic bottom-up computation, on the other hand,
                would calculate each smaller number only once and then use those values to move up
                to larger numbers.<a href="#ftn.d5e158" class="footnote" id="d5e158"><sup class="footnote">[6]</sup></a></p><p>Sequence alignment meets the two requirements for a problem to be amenable to
                dynamic programming. First, it can be expressed recursively, that is, if the optimal
                alignment of two long sequences can be identified, the optimal alignment of their
                corresponding subsequences can be extracted as a subset of the longer alignment.
                Second, this recursion is overlapping, that is, the solution to a sub-alignment is a
                component of the solution to a longer alignment.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d5e162"/>The Needleman Wunsch algorithm</h3></div></div></div><p>The history of the Needleman Wunsch algorithm is described by Boes as
                follows:</p><div class="blockquote"><blockquote class="blockquote"><p>We will begin with the scoring system most commonly used when introducing the
                    Needleman-Wunsch algorithm: substitution scores for matched residues and linear
                    gap penalties. Although Needleman and Wunsch already discussed this scoring
                    system in their 1970 article [NW70], the form in which it is now most commonly
                    presented is due to Gotoh [Got82] (who is also responsible for the affine gap
                    penalties version of the algorithm). An alignment algorithm very similar to
                    Needleman-Wunsch, but developed for speech recognition, was also independently
                    described by Vintsyuk in 1968 [Vin68]. Another early author interested in the
                    subject is Sellers [Sel74], who described in 1974 an alignment algorithm
                    minimizing sequence distance rather than maximizing sequence similarity; however
                    Smith and Waterman (two authors famous for the algorithm bearing their name)
                    proved in 1981 that both procedures are equivalent [SWF81]. Therefore it is
                    clear that there are many classic papers, often a bit old, describing
                    Needleman-Wunsch and its variants using different mathematical notations. (<a class="xref" href="#boes_2014">Boes 2014</a> 14; pointers are to <a class="xref" href="#needleman_1970">Needleman and Wunsch 1970</a>,
                        <a class="xref" href="#gotoh_1982">Gotoh 1982</a>, <a class="xref" href="#vintsyuk_1968">Vintsyuk 1968</a>, <a class="xref" href="#sellers_1974">Sellers 1974</a>, and <a class="xref" href="#smith_1981">Smith et al. 1981</a>)</p></blockquote></div><p>Boes further explains that Needleman Wunsch <span class="quote">“<span class="quote">is an
                        <span class="emphasis"><em>optimal</em></span> algorithm, which means that it produces the
                    best possible solution with respect to the chosen scoring system. There [exists]
                    also non-optimal alignment algorithms, most notably the heuristic methods
                    …</span>”</span> [<a class="xref" href="#boes_2014">Boes 2014</a>, 13]</p><p>Performing alignment according to the Needleman Wunsch dynamic programming
                algorithm entails the following steps:<a href="#ftn.d5e178" class="footnote" id="d5e178"><sup class="footnote">[7]</sup></a>
                </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Construct a grid with one sequence along the top, labeling the
                            columns, and the other along the left, labeling the rows.</p></li><li class="listitem"><p>Determine a scoring system. Here we score matches as 1, mismatches as
                            -1, and gaps as -2.</p></li><li class="listitem"><p>Insert a row at the top, below the labels, with sequential numbers
                            reflecting multiples of the gap score. For example, if the gap score is
                            -2, the values would be 0, -2, -4, etc. Starting from the 0, assign
                            similar values to a column inserted on the left, after the row labels.
                            By this point the grid should look like:</p><div class="table"><a id="d5e188"/><p class="title"><strong>Table 2. Initial grid for Needleman Wunsch</strong></p><div class="table-contents"><table class="table" summary="Initial grid for Needleman Wunsch" border="1"><colgroup><col/><col/><col/><col/><col/><col/><col/></colgroup><tbody><tr><td> </td><td> </td><td align="center">k</td><td align="center">o</td><td align="center">a</td><td align="center">l</td><td align="center">a</td></tr><tr><td> </td><td align="right">0</td><td align="right">-2</td><td align="right">-4</td><td align="right">-6</td><td align="right">-8</td><td align="right">-10</td></tr><tr><td>c</td><td align="right">-2</td><td> </td><td> </td><td> </td><td> </td><td> </td></tr><tr><td>o</td><td align="right">-4</td><td> </td><td> </td><td> </td><td> </td><td> </td></tr><tr><td>l</td><td align="right">-6</td><td> </td><td> </td><td> </td><td> </td><td> </td></tr><tr><td>a</td><td align="right">-8</td><td> </td><td> </td><td> </td><td> </td><td> </td></tr></tbody></table></div></div><p><br class="table-break"/></p></li><li class="listitem"><p>Starting in the upper left of the table body, where the first items of
                            the two sequences intersect, and proceeding across each row in turn,
                            from top to bottom, write a value into each cell. That value should be
                            the highest of the following three candidate values:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The cell immediately above plus the gap score.</p></li><li class="listitem"><p>The cell immediately to the left plus the gap
                                        score.</p></li><li class="listitem"><p>The cell immediately diagonally above to the left plus the
                                        match or mismatch score, depending on whether the
                                        intersecting sequence items constitute a match or a
                                        mismatch.</p></li></ul></div><p> For example, the first cell is the intersection of the
                                <span class="quote">“<span class="quote">k</span>”</span> at the top with <span class="quote">“<span class="quote">c</span>”</span> at the left, which
                            is a mismatch, since they are different. The cell immediately above has
                            a value of -2, which, when combined with the gap score, yields a value
                            of -4. The same is true of the cell immediately to the left. The cell
                            diagonally above and to the left has a value of 0, which, when combined
                            with the mismatch score, yields a value of -1. Since that is the highest
                            value, write it into the cell. Proceed across the first row, then
                            traverse the second row from left to right, etc., ending in the lower
                            right. The grid should now look like:</p><div class="table"><a id="d5e251"/><p class="title"><strong>Table 3. Completed grid for Needleman Wunsch</strong></p><div class="table-contents"><table class="table" summary="Completed grid for Needleman Wunsch" border="1"><colgroup><col/><col/><col/><col/><col/><col/><col/></colgroup><tbody><tr><td> </td><td> </td><td align="center">k</td><td align="center">o</td><td align="center">a</td><td align="center">l</td><td align="center">a</td></tr><tr><td> </td><td align="right">0</td><td align="right">-2</td><td align="right">-4</td><td align="right">-6</td><td align="right">-8</td><td align="right">-10</td></tr><tr><td>c</td><td align="right">-2</td><td align="right">-1</td><td align="right">-3</td><td align="right">-5</td><td align="right">-7</td><td align="right">-9</td></tr><tr><td>o</td><td align="right">-4</td><td align="right">-3</td><td align="right">0</td><td align="right">-2</td><td align="right">-4</td><td align="right">-6</td></tr><tr><td>l</td><td align="right">-6</td><td align="right">-5</td><td align="right">-2</td><td align="right">-1</td><td align="right">-1</td><td align="right">-3</td></tr><tr><td>a</td><td align="right">-8</td><td align="right">-7</td><td align="right">-4</td><td align="right">-1</td><td align="right">-2</td><td align="right">0</td></tr></tbody></table></div></div><p><br class="table-break"/> We fill the cells in the specified order because each cell
                            depends on two values from the row above (the cell immediately above and
                            the one diagonally above and to the left) and the preceding cell of the
                            same row. Filling in the cells from left to right and top to bottom
                            ensures that these values will be available when needed. For reasons
                            discussed below, these ordering dependencies pose a challenge for an
                            XSLT implementation.</p></li><li class="listitem"><p>Starting in the lower right corner, trace back through the sources
                            that determined the score of each cell. For example, the 0 value in the
                            lower right inherited from the upper diagonal left because the
                                <span class="quote">“<span class="quote">-1</span>”</span> that was there plus the match score of
                                <span class="quote">“<span class="quote">1</span>”</span> yielded a <span class="quote">“<span class="quote">0</span>”</span>, and that value was
                            higher than the scores coming from the cell immediately above
                                (<span class="quote">“<span class="quote">-3</span>”</span> plus the gap score of <span class="quote">“<span class="quote">-2</span>”</span> yields
                                <span class="quote">“<span class="quote">-5</span>”</span>) or to immediately to the left (<span class="quote">“<span class="quote">-2</span>”</span>
                            plus the gap score of <span class="quote">“<span class="quote">-2</span>”</span> yields <span class="quote">“<span class="quote">-4</span>”</span>). In
                            the following image we have 1) added arrows indicating the source of
                            each value entered into the grid and 2) shaded match cells green and
                            mismatch cells pink: </p><div class="figure"><a id="d5e314"/><p class="title"><strong>Figure 1. Completed alignment grid</strong></p><div class="figure-contents"><div class="mediaobject"><img src="../../images/completed_grid.png" alt="Completed alignment grid"/></div></div></div><p><br class="figure-break"/></p></li><li class="listitem"><p>At each step along this traceback path, starting from the lower right,
                            if the step is diagonal and up, align one item from the end of each
                            sequence. If the step is to the left, align an item from the sequence at
                            the top with a gap (that is, do not select an item from the sequence at
                            the left). If the step is up, align an item from the sequence at the
                            left with a gap. In case of ties, the choices with the highest value are
                            all optimal and can be pursued as alternatives. In the present case,
                            this process produces the following single optimal alignment: </p><div class="figure"><a id="d5e321"/><p class="title"><strong>Figure 2. Alignment table</strong></p><div class="figure-contents"><div class="mediaobject"><img src="../../images/completed_alignment.png" alt="Alignment table"/></div></div></div><p><br class="figure-break"/></p></li></ol></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e326"/>The challenges of dynamic programming and XSLT</h2></div></div></div><p>XSLT, at least before version 3.0, plays poorly with dynamic programming because each
            step in a dynamic programming algorithm depends on a value calculated at the preceding
            step. Functional programming of the sort supported by XSLT
                <code class="sgmltag-element">&lt;xsl:for-each&gt;</code> does not have access to these incremental values; if
            we try to run <code class="sgmltag-element">&lt;xsl:for-each&gt;</code> over all of the cells and populate them
            according to the values before and above them, those neighboring values will be the
            values in place initially, that is, null. The reason is that
                <code class="sgmltag-element">&lt;xsl:for-each&gt;</code> is not an iterative instruction: it <span class="emphasis"><em>orders
                the output</em></span> according to the input sequence, but it does not necessarily
                <span class="emphasis"><em>perform the computation</em></span> in that order. This is a feature
            because it means that such instructions can be parallelized, since no step is dependent
            on the output of any other step. But it also means that populating the Needleman Wunsch
            grid in XSLT requires an alternative to <code class="sgmltag-element">&lt;xsl:for-each&gt;</code>.</p><p>Tennison draws our attention to this issue in her XSLT 2.0 implementations of a
            dynamic programming algorithm to calculate Levenshtein distance (<a class="xref" href="#tennison_2007a">Tennison 2007a</a>, <a class="xref" href="#tennison_2007b">Tennison 2007b</a>), and with respect to
            constructing the grid, the algorithms for Levenshtein and Needleman Wunsch are
            analogous. The principal difference is that Levenshtein cares only about the value of
            the lower right cell, and therefore does not require the traceback steps the Needleman
            Wunsch uses to perform the alignment of actual sequence items.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d5e338"/>Why recursion breaks</h3></div></div></div><p>The traditional way to mimic updating a variable in XSLT is with recursion,
                passing the updated value into each recursive call. The challenge to this approach
                is that deep recursion can consume enough memory to overflow the available stack
                space and crash the operation. XSLT processors can work around this limitation with
                    <span class="emphasis"><em>tail recursion optimization</em></span>, which enables the processor to
                recognize when stack values do not have to be preserved. Tail recursion is finicky,
                however, first because not all processors support it, second because functions have
                to be written in a particular way to make it possible, and third because, insofar as
                it is an optimization, some operations that can be understood as tail recursive may
                not look that way to the processor, and may therefore fail to be optimized.</p><p>The important insight in Tennison’s second engagement with the Levenshtein problem
                    (<a class="xref" href="#tennison_2007b">Tennison 2007b</a>) is that it is possible to construct the grid
                values for Levenshtein (and therefore also for Needleman Wunsch) without recurring
                on every cell. By writing values into the grid on the diagonal, instead of across
                each row in turn, as is traditional, Tennison is able to calculate all values on an
                individual diagonal at the same time, since the cells on diagonals that run from top
                right to bottom left have no mutual dependencies. That is, while the traditional
                horizontal and then vertical traversal makes each step dependent on the one that
                immediately precedes it, traversal on the diagonal is possible because all of the
                information needed to process the entire next diagonal available simultaneously. The
                absence of dependencies within a diagonal means that Tennison can use
                    <code class="sgmltag-element">&lt;xsl:for-each&gt;</code> for all of the values on each diagonal, and
                recur only as she moves to a new diagonal. The computational complexity of
                populating the grid remains <span class="emphasis"><em>O(mn)</em></span>, since it is still necessary
                to calculate each cell individually, but Tennison’s implementation reduces the
                recursion from the number of cells to the number of diagonals, which is <span class="emphasis"><em>n
                    + m - 1</em></span>, that is, linear with respect to the total number of items in
                the two sequences. The substantial improvement in computational efficiency that
                results from an implementation <span class="quote">“<span class="quote">on the diagonal</span>”</span> was pointed out first
                by <a class="xref" href="#wang_2002">Wang 2002</a> (8), and then by <a class="xref" href="#naveed_2005">Naveed et al, 2005</a> (3–4),
                but although Wang first reported that items on the diagonal could be processed in
                parallel, it was Tennison who recognized that this observation could also be used to
                reduce the depth of recursion in XSLT.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d5e350"/>Iteration to the rescue</h3></div></div></div><p>Tennison’s diagonal implementation reduced the depth of recursion, but because the
                values in each diagonal continued to depend on the values in the immediately
                preceding diagonal, it nonetheless required recursion on each new diagonal. The
                reduction in the depth of recursion scaled impressively; for example, with two
                20-item sequences and 400 cells, the traditional method would have recurred 400
                times, while the diagonal method makes only 39 function calls—although very large
                input could still produce a stack overflow in situations where tail recursion
                optimization is not available. In XSLT 3.0, however, it is possible to use
                    <code class="sgmltag-element">&lt;xsl:iterate&gt;</code> to avoid recursive coding entirely:</p><div class="blockquote"><blockquote class="blockquote"><p>[xsl:iterate] is similar to xsl:for-each, except that the items in the
                        input sequence are processed sequentially, and after processing each item in
                        the input sequence it is possible to set parameters for use in the next
                        iteration. It can therefore be used to solve problems that in XSLT 2.0
                        require recursive functions or templates. (<a class="xref" href="#saxon_iterate">Saxon xsl:iterate</a>)</p></blockquote></div><p> The use of <code class="sgmltag-element">&lt;xsl:iterate&gt;</code>, which was not part of the
                XSLT 2.0 that was available to Tennison in 2007, in place of the recursion that she
                was forced to retain thus observes her wise recommendation to <span class="quote">“<span class="quote">try to iterate
                    rather than recurse whenever you can</span>”</span> (<a class="xref" href="#tennison_2007b">Tennison 2007b</a>).
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d5e360"/>Processing the diagonal</h3></div></div></div><p>The XSLT 3.0 <code class="sgmltag-element">&lt;xsl:iterate&gt;</code> element can be used for any repetitive
                operation, and our first XSLT 3.0 implementation of Needleman Wunsch resembled
                Tennison’s first (non-diagonal) Levenshtein implementation, in <a class="xref" href="#tennison_2007a">Tennison 2007a</a>, except that we used <code class="sgmltag-element">&lt;xsl:iterate&gt;</code>
                where she used recursion, that is, to process every cell. Because
                    <code class="sgmltag-element">&lt;xsl:iterate&gt;</code> is not dependent on a recursive stack, this
                implementation runs to completion even with large input.<a href="#ftn.d5e367" class="footnote" id="d5e367"><sup class="footnote">[8]</sup></a> It is, however, possible to improve the efficiency of the code by taking
                the admonition in <a class="xref" href="#tennison_2007b">Tennison 2007b</a> literally, that is, by
                understanding it, as Tennison did, as meaning <span class="quote">“<span class="quote">iterate <span class="emphasis"><em>rather than
                        recurse</em></span> whenever you can</span>”</span>, rather than, as in our naïve
                first implementation, <span class="quote">“<span class="quote">iterate <span class="emphasis"><em>absolutely whenever</em></span> you
                    can</span>”</span>. In other words, we should use iteration where recursion would have
                been required in XSLT 2.0, but not as a replacement for
                    <code class="sgmltag-element">&lt;xsl:for-each&gt;</code>, which we should retain where
                appropriate.</p><p>In the Needleman Wunsch (and also Levenshtein) context, as <a class="xref" href="#wang_2002">Wang 2002</a> and <a class="xref" href="#naveed_2005">Naveed et al, 2005</a> point out, all values on
                the same diagonal can be calculated in parallel, and Tennison’s use of
                    <code class="sgmltag-element">&lt;xsl:for-each&gt;</code> in her improved code, in <a class="xref" href="#tennison_2007b">Tennison 2007b</a>, to process the diagonal is compatible with this
                observation because <code class="sgmltag-element">&lt;xsl:for-each&gt;</code> can be parallelized. Whether it
                    <span class="emphasis"><em>is</em></span> executed in parallel, however, is often unpredictable,
                since XSLT does not give the programmer explicit control over processes or threads
                in the same way as other languages (cf. Python’s <code class="code">multiprocessing</code>
                module). However, Saxon EE (although not PE or HE) provides a custom <code class="sgmltag-attribute">@saxon:threads</code> attribute that allows the developer to
                specify that an <code class="sgmltag-element">&lt;xsl:for-each&gt;</code> element should be processed in
                parallel. The documentation explains that: </p><div class="blockquote"><blockquote class="blockquote"><p>This attribute may be set on the xsl:for-each instruction. The value must
                        be an integer. When this attribute is used with Saxon-EE, the items selected
                        by the select expression of the instruction are processed in parallel, using
                        the specified number of threads. (<a class="xref" href="#saxon_threads">Saxon saxon:threads</a>)</p></blockquote></div><p> The Saxon documentation goes on to explain, however, that: </p><div class="blockquote"><blockquote class="blockquote"><p>Processing using multiple threads can take advantage of multi-core CPUs.
                        However, there is an overhead, in that the results of processing each item
                        in the input need to be buffered. The overhead of coordinating multiple
                        threads is proportionally higher if the per-item processing cost is low,
                        while the overhead of buffering is proportionally higher if the amount of
                        data produced when each item is processed is high. Multi-threading therefore
                        works best when the body of the xsl:for-each instruction performs a large
                        amount of computation but produces a small amount of output. (<a class="xref" href="#saxon_threads">Saxon saxon:threads</a>)</p></blockquote></div><p>With this in mind, we revised our first implementation to iterate only to move
                through the diagonals, using <code class="sgmltag-element">&lt;xsl:for-each&gt;</code> to process the items
                within an individual diagonal. The ordinal position of the diagonal (in a sweep that
                moves from the one-cell diagonal in the upper left to the one-cell diagonal in the
                lower right) to which any cell belongs can be determined as a function of the row
                and column number. We compute that diagonal value at the same time as we determine
                the row and column numbers and store all three, together with whether the cell
                represents a match or non-match between the sequence item labeling the row and the
                one labeling the column, on the cell, so that a sample cell might look like
                    <code class="sgmltag-element">&lt;cell row="2" col="3" diag="4" match="-1"/&gt;</code>. We then use
                    <code class="sgmltag-element">&lt;xsl:for-each-group&gt;</code> to group the cells by diagonal, running
                    <code class="sgmltag-element">&lt;xsl:for-each&gt;</code> over the members of each group and rewriting the
                cells on the diagonal being processed to add new attributes that contain: the scores
                from relevant neighboring cells; which cell contributed the highest value; and the
                (highest) value itself, which becomes the content of the cell.<a href="#ftn.d5e401" class="footnote" id="d5e401"><sup class="footnote">[9]</sup></a> We constrain the search space for neighboring values by searching only
                the two preceding diagonals (which we return as separate parameters upon iteration),
                and we improve the retrieval from this space by using <code class="sgmltag-element">&lt;xsl:key&gt;</code>
                with a composite <code class="sgmltag-attribute">@use</code> attribute that indexes that
                search space according to <code class="sgmltag-attribute">@row</code> and <code class="sgmltag-attribute">@col</code> values.</p><p>It is possible for more than one neighboring cell to tie for highest value, and
                our implementation makes a simplifying assumption and identifies only one optimal
                path, even though there may be more than one, since the task that motivated this
                development required only <span class="emphasis"><em>an</em></span> optimal alignment, and not
                    <span class="emphasis"><em>all</em></span> such alignments. We limit ourselves to a single
                alignment result by recording only one path to each cell, resolving ties by
                arbitrarily favoring diagonal, then left, and only then upper sources. There is,
                however, nothing about the method that would prohibit recording and later processing
                multiple paths, and thus identifying all optimal alignments.</p><p>[ADD DETAILS]</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d5e411"/>Save yourself a trip … and some space</h3></div></div></div><p>The construction of the scoring grid for Needleman Wunsch is identical to the
                construction of the grid for Levenshtein, but, as was noted above, the key
                difference is what happens next: Levenshtein cares only about the value of the lower
                right cell, and therefore does not need to walk back through the grid the way
                Needleman Wunsch does to align the actual sequences. This means that a diagonal
                implementation for a Levenshtein distance calculation can throw away each diagonal
                once it is no longer needed, and the one-cell diagonal at the lower right will
                contain the one piece of information the function is expected to return: the
                distance between the two sequences.</p><p>The only reason we need the full grid in the Needleman Wunsch application is to
                traverse the path that led us to the lower right cell backward to the origin. At
                each step along that traversal the only information we need is the direction of the
                next step (up, left, or diagonal); we do not need the score and we do not need the
                row and column labels. This means that we can avoid this backward traversal for
                Needleman Wunsch entirely if we write the cumulative full path to each cell into the
                cell alongside its score, instead just the source of the most recent path step, so
                that the lower right cell will already contain information about the full path that
                led to it. We still need to iterate over the path steps and retrieve item values
                from the sequences to be aligned, but we retrieve those values from the original
                sequences, and not from the grid, which we no longer need. Avoiding this backwards
                trip through the grid comes at the cost of writing full path information into every
                cell during the initial construction of the grid, even though we will ultimately use
                this information only from the one lower right cell for the final traversal. But in
                compensation we can throw away diagonals along the way as we no longer need them,
                and we do not need to retain the entire grid only in order to traverse it to
                construct the alignment table.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e415"/>Conclusions</h2></div></div></div><p>The code that implements our method is available at <a class="link" href="https://github.com/djbpitt/xstuff/tree/master/nw" target="_top">https://github.com/djbpitt/xstuff/tree/master/nw</a>, and has not been
            reproduced here. It is densely commented, and thus offers tutorial information about the
            method. Small exploratory stylesheets that were used to develop individual components of
            the code have been retained in a <span class="emphasis"><em>scratch</em></span> subdirectory.</p><p>Tennison concludes her second, improved computation of Levenshtein distance by writing
            that:</p><div class="blockquote"><blockquote class="blockquote"><p>I guess the take-home messages are: (a) try to iterate rather than recurse
                    whenever you can and (b) don’t blindly adapt algorithms designed for procedural
                    programming languages to XSLT. [<a class="xref" href="#tennison_2007b">Tennison 2007b</a>]</p></blockquote></div><p>The XSLT 3.0 <code class="sgmltag-element">&lt;xsl:iterate&gt;</code> element provides a robust method to
            iterate reliably that was not available to Tennison in 2007. Beyond that, the
            implementation above extends Tennison’s XSLT-idiomatic implementation of a Levenshtein
            distance algorithm to the closely related domain of Needleman Wunsch sequence alignment,
            with attention to the additional step of traversing the optimal path to construct the
            actual alignment. Finally, the present report also emphasizes that although
                <code class="sgmltag-element">&lt;xsl:iterate&gt;</code> can be used for any repetitive operation, the use of
                <code class="sgmltag-element">&lt;xsl:for-each&gt;</code> where it is appropriate, especially when combined
            with the Saxon EE <code class="sgmltag-attribute">@saxon:threads</code> attribute, enables
            parallel execution that would not be available it <code class="sgmltag-element">&lt;xsl:iterate&gt;</code> were
            used everywhere a sequence is processed.</p></div><div class="bibliography"><div class="titlepage"><div><div><h2 class="title"><a id="d5e431"/>Works cited</h2></div></div></div><div class="bibliomixed"><a id="bellman_1952"/><p class="bibliomixed">[Bellman 1952] Bellman, Richard E. 1952.
                <span class="quote">“<span class="quote">On the theory of dynamic programming.</span>”</span>
            <span class="citetitle"><em class="citetitle">Proceedings of the National Academy of Sciences</em></span> 38(8):716–19.
                <a class="link" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1063639/" target="_top">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1063639/</a></p></div><div class="bibliomixed"><a id="bellman_1954"/><p class="bibliomixed">[Bellman 1954] Bellman, Richard E. <span class="quote">“<span class="quote">The
                theory of dynamic programming.</span>”</span> Technical report P-550. Santa Monica: Rand
            Corporation. <a class="link" href="http://smo.sogang.ac.kr/doc/bellman.pdf" target="_top">http://smo.sogang.ac.kr/doc/bellman.pdf</a></p></div><div class="bibliomixed"><a id="birnbaum_2007"/><p class="bibliomixed">[Birnbaum 2007] Birnbaum, David J.
                <span class="quote">“<span class="quote">Sometimes a table is only a table: And sometimes a row is a column.</span>”</span>
            <span class="citetitle"><em class="citetitle">Proceedings of Extreme Markup Languages 2007.</em></span>
            <a class="link" href="http://conferences.idealliance.org/extreme/html/2007/Birnbaum01/EML2007Birnbaum01.html" target="_top">http://conferences.idealliance.org/extreme/html/2007/Birnbaum01/EML2007Birnbaum01.html</a></p></div><div class="bibliomixed"><a id="boes_2014"/><p class="bibliomixed">[Boes 2014] Boes, Olivier. 2014. <span class="quote">“<span class="quote">Improving
                the Needleman-Wunsch algorithm with the DynaMine predictor.</span>”</span> Master in
            Bioinformatics thesis, Université lire de Bruxelles. <a class="link" href="t.ly/rzxZZ" target="_top">t.ly/rzxZZ</a></p></div><div class="bibliomixed"><a id="collatex"/><p class="bibliomixed">[CollateX] CollateX—software for collating textual
            sources. <a class="link" href="https://collatex.net/" target="_top">https://collatex.net/</a></p></div><div class="bibliomixed"><a id="fv_reader"/><p class="bibliomixed">[Frankenstein variorum reader] <span class="quote">“<span class="quote">Mary
                Shelley’s Frankenstein. A digital variorum edition.</span>”</span>
            <a class="link" href="http://frankensteinvariorum.library.cmu.edu/viewer/" target="_top">http://frankensteinvariorum.library.cmu.edu/viewer/</a>. See also the
            project GitHub repo at <a class="link" href="https://github.com/FrankensteinVariorum/" target="_top">https://github.com/FrankensteinVariorum/</a>.</p></div><div class="bibliomixed"><a id="snip"/><p class="bibliomixed">[Global alignment] <span class="quote">“<span class="quote">Global alignment.
                Needleman-Wunsch.</span>”</span> Chapter 9 of Pairwise alignment, Bioinformatics Lessons at
            your convenience, Snipacademy. <a class="link" href="https://binf.snipcademy.com/lessons/pairwise-alignment/global-needleman-wunsch" target="_top">https://binf.snipcademy.com/lessons/pairwise-alignment/global-needleman-wunsch</a></p></div><div class="bibliomixed"><a id="gothenburg"/><p class="bibliomixed">[Gothenburg model] <span class="quote">“<span class="quote">The Gothenburg
                model.</span>”</span> Section 1 of the documentation for <a class="xref" href="#collatex">CollateX</a>. <a class="link" href="https://collatex.net/doc/#gothenburg-model" target="_top">https://collatex.net/doc/#gothenburg-model</a></p></div><div class="bibliomixed"><a id="gotoh_1982"/><p class="bibliomixed">[Gotoh 1982] Gotoh, Osamu. 1982. <span class="quote">“<span class="quote">An
                improved algorithm for matching biological sequences.</span>”</span>
            <span class="citetitle"><em class="citetitle">Journal of molecular biology</em></span> 162(3):705–08. <a class="link" href="http://www.genome.ist.i.kyoto-u.ac.jp/~aln_user/archive/JMB82.pdf" target="_top">http://www.genome.ist.i.kyoto-u.ac.jp/~aln_user/archive/JMB82.pdf</a></p></div><div class="bibliomixed"><a id="intertextual_dante"/><p class="bibliomixed">[Intertextual Dante] 
            <span class="quote">“<span class="quote">Intertextual Dante.</span>”</span>
            <a class="link" href="https://digitaldante.columbia.edu/intertexual-dante-vanpeteghem/" target="_top">https://digitaldante.columbia.edu/intertexual-dante-vanpeteghem/</a>
        </p></div><div class="bibliomixed"><a id="juxta"/><p class="bibliomixed">[Juxta] Juxta. <a class="link" href="https://www.juxtasoftware.org/" target="_top">https://www.juxtasoftware.org/</a></p></div><div class="bibliomixed"><a id="msa"/><p class="bibliomixed">[Multiple sequence alignment (Wikipedia)] Multiple
            sequence alignment (Wikipedia). Accessed 2019-11-03. <a class="link" href="https://en.wikipedia.org/wiki/Multiple_sequence_alignment" target="_top">https://en.wikipedia.org/wiki/Multiple_sequence_alignment</a></p></div><div class="bibliomixed"><a id="naveed_2005"/><p class="bibliomixed">[Naveed et al, 2005] Naveed, Tahir,Imitaz Saeed
            Siddiqui, Shaftab Ahmed. 2005. <span class="quote">“<span class="quote">Parallel Needleman-Wunsch algorithm for
                grid.</span>”</span> Proceedings of the PAK-US International Symposium on High Capacity
            Optical Networks and Enabling Technologies (HONET 2005), Islamabad, Pakistan, Dec 19–21,
            2005. <a class="link" href="https://upload.wikimedia.org/wikipedia/en/c/c4/ParallelNeedlemanAlgorithm.pdf" target="_top">https://upload.wikimedia.org/wikipedia/en/c/c4/ParallelNeedlemanAlgorithm.pdf</a></p></div><div class="bibliomixed"><a id="needleman_1970"/><p class="bibliomixed">[Needleman and Wunsch 1970] Needleman, Saul
            B. and Christian D. Wunsch. 1970. <span class="quote">“<span class="quote">A general method applicable to the search for
                similarities in the amino acid sequence of two proteins.</span>”</span>
            <span class="citetitle"><em class="citetitle">Journal of molecular biology</em></span> 48 (3): 443–53.
            doi:10.1016/0022-2836(70)90057-4.</p></div><div class="bibliomixed"><a id="saxon_threads"/><p class="bibliomixed">[Saxon saxon:threads] Saxon documentation of
                <span class="emphasis"><em>saxon:threads</em></span>. <a class="link" href="https://www.saxonica.com/html/documentation/extensions/attributes/threads.html" target="_top">https://www.saxonica.com/html/documentation/extensions/attributes/threads.html</a></p></div><div class="bibliomixed"><a id="saxon_iterate"/><p class="bibliomixed">[Saxon xsl:iterate] Saxon documentation of
                <span class="emphasis"><em>xsl:iterate</em></span>. <a class="link" href="http://www.saxonica.com/documentation/index.html#!xsl-elements/iterate" target="_top">http://www.saxonica.com/documentation/index.html#!xsl-elements/iterate</a></p></div><div class="bibliomixed"><a id="sellers_1974"/><p class="bibliomixed">[Sellers 1974] Sellers, Peter H. 1974.
                <span class="quote">“<span class="quote">On the theory and computation of evolutionary distances.</span>”</span>
            <span class="citetitle"><em class="citetitle">SIAM journal on applied mathematics</em></span> 26(4):787–93.</p></div><div class="bibliomixed"><a id="smith_1981"/><p class="bibliomixed">[Smith et al. 1981] Smith, Temple F., Michael S.
            Waterman, and Walter M. Fitch. 1981. <span class="quote">“<span class="quote">Comparative biosequence metrics.</span>”</span>
            <span class="citetitle"><em class="citetitle">Journal of molecular evolution</em></span>, 18(1):38–46. <a class="link" href="https://www.researchgate.net/publication/15863628_Comparative_biosequence_metrics" target="_top">https://www.researchgate.net/publication/15863628_Comparative_biosequence_metrics</a></p></div><div class="bibliomixed"><a id="tennison_2007a"/><p class="bibliomixed">[Tennison 2007a] Tennison, Jeni. 2007.
                <span class="quote">“<span class="quote">Levenshtein distance in XSLT 2.0.</span>”</span> Posted to <span class="citetitle"><em class="citetitle">Jeni’s
                musings</em></span>, 2007-05-03. <a class="link" href="https://www.jenitennison.com/2007/05/06/levenshtein-distance-on-the-diagonal.html" target="_top">https://www.jenitennison.com/2007/05/06/levenshtein-distance-on-the-diagonal.html</a></p></div><div class="bibliomixed"><a id="tennison_2007b"/><p class="bibliomixed">[Tennison 2007b] Tennison, Jeni. 2007.
                <span class="quote">“<span class="quote">Levenshtein distance on the diagonal.</span>”</span> Posted to <span class="citetitle"><em class="citetitle">Jeni’s
                musings</em></span>, 2007-05-06. <a class="link" href="https://www.jenitennison.com/2007/05/06/levenshtein-distance-on-the-diagonal.html" target="_top">https://www.jenitennison.com/2007/05/06/levenshtein-distance-on-the-diagonal.html</a></p></div><div class="bibliomixed"><a id="trovato_2014"/><p class="bibliomixed">[Trovato 2014] Trovato, Paolo.
                <span class="citetitle"><em class="citetitle">Everything you always wanted to know about Lachmann’s method. A
                non-standard handbook of genealogical textual criticism in the age of
                post-structuralism, cladistics, and copy-text.</em></span> Padova:
            libreriauniversitaria.it , 2014</p></div><div class="bibliomixed"><a id="peteghhem_2015"/><p class="bibliomixed">[Van Peteghem 2015] Van Peteghem, Julie.
            2015. <span class="quote">“<span class="quote">Digital readers of allusive texts: Ovidian intertextuality in the Commedia
                and the Digital concordance on intertextual Dante.</span>”</span>
            <span class="citetitle"><em class="citetitle">Humanist studies &amp; the digital age</em></span>, 4.1, 39–59. DOI:
            10.5399/uo/hsda.4.1.3584. <a class="link" href="http://journals.oregondigital.org/index.php/hsda/article/view/3584" target="_top">http://journals.oregondigital.org/index.php/hsda/article/view/3584</a></p></div><div class="bibliomixed"><a id="vintsyuk_1968"/><p class="bibliomixed">[Vintsyuk 1968] Vintsyuk, T[aras] K[lymovych].
            1968. <span class="quote">“<span class="quote">Speech discrimination by dynamic programming.</span>”</span>
            <span class="citetitle"><em class="citetitle">Cybernetics</em></span> 4(1):52–57.</p></div><div class="bibliomixed"><a id="wang_2002"/><p class="bibliomixed">[Wang 2002] Wang, Bin. 2002. <span class="quote">“<span class="quote">Implementation
                of a dynamic programming algorithm for DNA sequence alignment on the cell matrix
                architecture. MA thesis, Utah State University.</span>”</span>
            <a class="link" href="https://www.cellmatrix.com/entryway/products/pub/wang2002.pdf" target="_top">https://www.cellmatrix.com/entryway/products/pub/wang2002.pdf</a></p></div></div><div class="appendix"><h2 class="title" style="clear: both"><a id="d5e510"/>A. Modeling alignment as table and graph</h2><p>The dynamic programming paradigm underlying Needleman Wunsch traditionally models the
            information that determines the optimal alignment as a grid or table, where the items in
            one of the sequences to be aligned label the rows and the items in the other sequence
            label the columns. In our first implementation we build this grid as a row-major table:
            a <code class="sgmltag-element">&lt;table&gt;</code> root element contains <code class="sgmltag-element">&lt;row&gt;</code> children, which,
            in turn, contain <code class="sgmltag-element">&lt;cell&gt;</code> children, one per column. This hierarchical
            table structure is conceptually wrong because it privileges rows over columns, and it is
            not the nature of tables (or, at least, of this particular table) that either rows
            should be hierarchically superior to columns or vice versa. The hierarchical table is
            also awkward from an engineering perspective because it requires us, in order to
            identify the location of the neighboring cells that contribute to determining a value,
            to use rather complex XPath path expressions to dereference the position of the current
            context cell. If, however, every cell knows its row and column membership without having
            to query its location in a table hierarchy, we avoid having to evaluate those path
            expressions. Among other things, recording logical row and column positions as
            attributes on the cells makes the code that constructs and navigates diagonals easier to
            read.</p><p>For these conceptual and practical reasons, in our second implementation we model the
            dynamic programming table as a flat and logically unordered set of
                <code class="sgmltag-element">&lt;cell&gt;</code> elements, each of which stores its conceptual row and column
            membership in attributes.<a href="#ftn.d5e518" class="footnote" id="d5e518"><sup class="footnote">[10]</sup></a> If we think of the cells as nodes in a graph, information about (conceptual)
            adjacency edges is only implicit, in that adjacent cells are discoverable not by edges
            that specify both ends, but by performing arithmetic on the current <code class="sgmltag-attribute">@row</code> and <code class="sgmltag-attribute">@col</code> values to compute
            the values of adjacent cells. As we add scores to the graph progressively and record
            which neighboring cell was responsible for the new value, we add an explicit directed
            edge, stored on the cell that contains the new value as a pointer to the cell
            responsible for that value.</p><p>We can think of this model, then, as two connected, directed, acyclic graphs expressed
            over the same set of nodes, which are the cells. The first is the initial adjacency
            graph, rooted at what would be row 1, column 1 in a table, which is fully connected by
            implicit directed edges that join cells to those immediately following in what would be
            row or column order. The second graph is rooted in what would be the last row and column
            in a table, with directed edges that point back from each cell to the cell that
            contributed its score value. While all cells contain directed pointers to the source of
            their values, those that are not reachable from the lower right corner of the conceptual
            table are ignored. It may be possible to construct more than one path from the lower
            right corner of the conceptual table, representing more than one optimal sequence
            alignment, but because our requirement is a single optimal path, and not all optimal
            paths, we do not add all possible edges to this second graph, and, as a result, we
            arrive at a single path.</p></div><div class="footnotes"><br/><hr style="width:100; text-align:left;margin-left: 0"/><div id="ftn.d5e28" class="footnote"><p><a href="#d5e28" class="para"><sup class="para">[1] </sup></a><span class="emphasis"><em>Witness</em></span>, sometimes expanded as <span class="emphasis"><em>manuscript
                            witness</em></span>, is a technical term in text-critical scholarship for
                        a manuscript that provides evidence of the history of a text.</p></div><div id="ftn.d5e32" class="footnote"><p><a href="#d5e32" class="para"><sup class="para">[2] </sup></a>For an introduction to, among other things, the evaluation of shared and
                        divergent readings as a component of textual criticism see <a class="xref" href="#trovato_2014">Trovato 2014</a>.</p></div><div id="ftn.d5e76" class="footnote"><p><a href="#d5e76" class="para"><sup class="para">[3] </sup></a>For further information about the Gothenburg model see <a class="xref" href="#gothenburg">Gothenburg model</a>.</p></div><div id="ftn.d5e81" class="footnote"><p><a href="#d5e81" class="para"><sup class="para">[4] </sup></a><a class="xref" href="#msa">Multiple sequence alignment (Wikipedia)</a> provides an overview of multiple
                                    sequence alignment, the term in bioinformatics for what
                                    philologists refer to as multiple-witness alignment.</p></div><div id="ftn.d5e154" class="footnote"><p><a href="#d5e154" class="para"><sup class="para">[5] </sup></a>For more information about dynamic programming see <a class="xref" href="#bellman_1952">Bellman 1952</a> and <a class="xref" href="#bellman_1954">Bellman 1954</a>.</p></div><div id="ftn.d5e158" class="footnote"><p><a href="#d5e158" class="para"><sup class="para">[6] </sup></a>A top-down dynamic approach would perform all of the recursive computation
                        at the beginning, but <span class="emphasis"><em>memoize</em></span> (that is, store and
                        index) the sub-calculations, so that they could be looked up and reused,
                        without having to be recomputed, when needed at the next level down.</p></div><div id="ftn.d5e178" class="footnote"><p><a href="#d5e178" class="para"><sup class="para">[7] </sup></a>For a clear and more detailed explanation see <a class="xref" href="#snip">Global alignment</a>.</p></div><div id="ftn.d5e367" class="footnote"><p><a href="#d5e367" class="para"><sup class="para">[8] </sup></a>By <span class="emphasis"><em>large</em></span> we mean sequences of a few hundred, but not
                        several thousand, items. Although the implementation is iterative, rather
                        than recursive, the algorithm nonetheless has quadratic complexity (the
                        number of cells is the product of the number of items in the two sequences),
                        and this, our first (naïve) implementation, cannot be parallelized because
                        the computation of each cell must wait for the completion of the computation
                        of preceding cells. The iterative implementation will not overflow the
                        stack, but the time it requires to run to completion nonetheless grows
                        quadratically.</p><p>A possibly perverse attempt to align a sequence of 11130 items against a
                        sequence of 12392 items using Saxon-HE 9.9.1.4J with default settings on
                        6-core machine with 32G of RAM crashed after several hours with a Java
                            <span class="quote">“<span class="quote">GC overhead limit exceeded</span>”</span> error. Aligning a much more
                        modest sequence of 233 items against a sequence of 223 items using our
                        non-diagonal implementation, which creates a grid and an alignment table and
                        renders both in HTML, overflowed the stack without
                            <code class="sgmltag-element">&lt;xsl:iterate&gt;</code>, and with <code class="sgmltag-element">&lt;xsl:iterate&gt;</code>
                        it returned times of real 0m2.842s, user 0m6.519s, sys 0m0.494s.</p></div><div id="ftn.d5e401" class="footnote"><p><a href="#d5e401" class="para"><sup class="para">[9] </sup></a>Much of the information stored in attribute values is used once, to
                        calculate the score for the new cell, and does not need to be preserved. We
                        retain it here only for debugging and reporting purposes.</p></div><div id="ftn.d5e518" class="footnote"><p><a href="#d5e518" class="para"><sup class="para">[10] </sup></a>We refer to <span class="emphasis"><em>conceptual</em></span> row and column membership because
                    there are no <code class="sgmltag-element">&lt;row&gt;</code> elements or <code class="sgmltag-element">&lt;column&gt;</code>
                    elements, and the cells are not organized hierarchically. A more scrupulous way
                    of describing these properties might be that they record not membership in a row
                    or column, but a relationship property that cells have to items in the two
                    sequences to be aligned. We have implemented these properties as attributes that
                    we call <code class="sgmltag-attribute">@row</code> and <code class="sgmltag-attribute">@col</code>
                    because the spatial metaphor of a table is easy to understand. See <a class="xref" href="#birnbaum_2007">Birnbaum 2007</a> for a discussion of these modeling issues.</p></div></div></div></body></html>