<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Sequence alignment in XSLT 3.0</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.2"/><meta name="description" content="The Needleman Wunsch algorithm, which this year celebrates its quinquagenary anniversary, has been proven to produce an optimal global pairwise sequence alignment. Because this dynamic programming algorithm requires the progressive updating of mutually dependent variables, it poses challenges for functional programming paradigms like the one underlying XSLT. The present report explores these challenges and provides an implementation of the Needleman Wunsch algorithm in XSLT 3.0."/><meta name="keywords" content="sequence alignment, xslt"/></head><body><div xml:lang="en" class="article"><div class="titlepage"><div><div><h2 class="title"><a id="d5e1"/>Sequence alignment in XSLT 3.0</h2></div><div><div class="author"><h3 class="author">[Author’s name and affiliation redacted]</h3></div></div><div><div class="abstract"><p class="title"><strong>Abstract</strong></p><p>The Needleman Wunsch algorithm, which this year celebrates its quinquagenary
                anniversary, has been proven to produce an optimal global pairwise sequence
                alignment. Because this dynamic programming algorithm requires the progressive
                updating of mutually dependent variables, it poses challenges for functional
                programming paradigms like the one underlying XSLT. The present report explores
                these challenges and provides an implementation of the Needleman Wunsch algorithm in
                XSLT 3.0.</p></div></div></div><hr/></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="#d5e11">Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e13">Why sequence aligment matters</a></span></dt><dt><span class="section"><a href="#d5e23">Biological and textual alignment</a></span></dt><dt><span class="section"><a href="#d5e33">Global pairwise alignment</a></span></dt><dt><span class="section"><a href="#d5e54">Overview of this report</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e70">About sequence alignment</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e72">Alignment and scoring</a></span></dt><dt><span class="section"><a href="#d5e128">Sequence alignment algorithms</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e137">Dynamic programming and the Needleman Wunsch algorithm</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e139">Dynamic programming</a></span></dt><dt><span class="section"><a href="#d5e159">The Needleman Wunsch algorithm</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e339">The challenges of dynamic programming and XSLT</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e351">Why recursion breaks</a></span></dt><dt><span class="section"><a href="#d5e365">Iteration to the rescue</a></span></dt><dt><span class="section"><a href="#d5e375">Processing the diagonal</a></span></dt><dt><span class="section"><a href="#d5e413">Save yourself a trip … and some space</a></span></dt><dt><span class="section"><a href="#d5e419">Performance</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e702">Conclusions</a></span></dt><dt><span class="bibliography"><a href="#d5e714">Works cited</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e11"/>Introduction</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d5e13"/>Why sequence aligment matters</h3></div></div></div><p>Sequence alignment is a way of identifying and modeling similarities and
                differences in sequences of items, and has proven insightful and productive for
                research in both the natural sciences (especially in biology and medicine, where it
                is applied to genetic sequences) and the humanities (especially in text-critical
                scholarship, where it is applied to sequences of words in variant versions of a
                text). In textual scholarship, which is the domain in which the present report was
                developed, sequence alignment assists the philologist in identifying locations where
                manuscript witnesses agree and where they disagree.<a href="#ftn.d5e16" class="footnote" id="d5e16"><sup class="footnote">[1]</sup></a> These agreements and disagreements, in turn, provide evidence about
                probable (or, at least, candidate) moments of shared transmission among textual
                witnesses, and thus serve as evidence to construct and support a philological
                argument about the history of a text.<a href="#ftn.d5e20" class="footnote" id="d5e20"><sup class="footnote">[2]</sup></a></p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d5e23"/>Biological and textual alignment</h3></div></div></div><p>Insofar as biomedical research enjoys a larger scientific community and richer
                funding resources than textual humanities scholarship, it is not surprising that the
                literature about sequence alignment, and the science reported in that literature, is
                quantitatively greater in the natural sciences than in the humanities. Furthermore,
                insofar as all sequence alignment is similar in certain mathematical ways, it is
                both necessary and appropriate for textual scholars to seek opportunities to adapt
                biomedical methods for their own purposes. For those reasons, the present report,
                although motivated by text-critical research, focuses on a method first proposed in
                a biological context and later also applied in philology.</p><p>This report does not take account of differences in the size and scale of
                biological and philological data, but it is nonetheless the case that alignment
                tasks in biomedical contexts, on the one hand, and in textual contexts, on the
                other, typically differ at least in the following ways: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Genetic alignment may operate at sequence lengths involving entire
                            chromosomes or entire genomes, which are orders of magnitude larger than
                            the largest real-world textual alignment tasks.</p></li><li class="listitem"><p>Genetic alignment operates with a vocabulary of four words (nucleotide
                            bases, although alignment may also be performed on codons), while
                            textual alignment often involves a vocabulary of hundreds or thousands
                            of different words.</p></li></ul></div><p>The preceding systematic differences in size and scale invite questions about
                whether the different shape of the source data in the two domains might invite
                different methods. Especially in the case of heuristic approaches that are not
                guaranteed to produce an optimal solution, is it possible that compromises required
                to make data at large scale computationally tractable might profitably be avoided in
                domains involving data at a substantially smaller scale? Although the present report
                does not engage with this question, it remains part of the context within which
                solutions to alignment tasks in different disciplines ultimately should be
                assessed.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d5e33"/>Global pairwise alignment</h3></div></div></div><p>The following two distinctions—not between biological and textual alignment, but
                within both domains—are also relevant to the present report:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Both genetic and textual alignment tasks can be divided into
                                <span class="emphasis"><em>global</em></span> and <span class="emphasis"><em>local</em></span>
                            alignment. The goal of global alignment is to find the best alignment of
                                <span class="emphasis"><em>all items in the entire sequences</em></span>. In textual
                            scholarship this is often called <span class="emphasis"><em>collation</em></span> (cf.
                            e.g., <a class="xref" href="#fv_reader">Frankenstein variorum reader</a>). The goal of local alignment is to
                            find moments where <span class="emphasis"><em>subsequences</em></span> correspond, without
                            attempting to optimize the alignment of the entire sequences. A common
                            textological application of local alignment is <span class="emphasis"><em>text
                                reuse</em></span>, e.g., finding moments where Dante quotes or
                            paraphrases Ovid (cf. <a class="xref" href="#peteghhem_2015">Van Peteghem 2015</a>, <a class="xref" href="#intertextual_dante">Intertextual Dante</a>).</p></li><li class="listitem"><p>Both genetic and textual alignment tasks may involve
                                <span class="emphasis"><em>pairwise alignment</em></span> or <span class="emphasis"><em>multiple
                                alignment</em></span>. Pairwise alignment refers to the alignment of
                            two sequences; multiple alignment refers to the alignment of more than
                            two sequences. In textual scholarship multiple alignment is often called
                                <span class="emphasis"><em>multiple-witness alignment</em></span>.</p></li></ul></div><p>The Needleman Wunsch algorithm described and implemented below has been proven to
                identify all optimal global pairwise alignments of two sequences, and it is
                especially well suited to alignment tasks where the two texts are of comparable size
                and are substantially similar to each other. The present report does not address
                either local alignment or multiple (witness) alignment.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d5e54"/>Overview of this report</h3></div></div></div><p>This report begins by introducing the use of dynamic programming methods in the
                Needleman Wunsch algorithm to ascertain all optimal global alignments of two
                sequences. It then identifies challenges to implementing this algorithm in XSLT and
                discusses those challenges in the context of developing such an implementation.
                Original code discussed in this report is available at <a class="link" href="https://github.com/djbpitt/xstuff/tree/master/nw" target="_top">https://github.com/djbpitt/xstuff/tree/master/nw</a>.</p><p>It should be noted that the goal of this report, and the code underlying it, is to
                explore global pairwise sequence alignment in an XSLT environment. For that reason,
                it is not intended that this code function as a stand-alone end-user textual
                collation tool. There are two reasons for specifying the goals and non-goals of the
                present report in this way: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Textual collation as a philological method involves more than just
                            alignment. For example, the Gothenburg model of textual collation, which
                            has been implemented in the CollateX [<a class="xref" href="#collatex">CollateX</a>] and
                            Juxta [<a class="xref" href="#juxta">Juxta</a>] tools, expresses the collation process
                            as a five-step pipeline, within which alignment serves as the third
                            step. [<a class="xref" href="#gothenburg">Gothenburg model</a>]</p></li><li class="listitem"><p>Real-world textual alignment tasks often involve more than two
                            witnesses, that is, they involve multiple-witness, rather than pairwise,
                            alignment. While some approaches to multiple-witness alignment are
                            implemented as a progressive or iterative application of pairwise
                            alignment, these methods are subject to order effects. Ultimately,
                            multiple-witness alignment is an NP hard problem with which the present
                            report does not seek to engage.<a href="#ftn.d5e67" class="footnote" id="d5e67"><sup class="footnote">[3]</sup></a></p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e70"/>About sequence alignment</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d5e72"/>Alignment and scoring</h3></div></div></div><p>An optimal alignment can be defined as an alignment that yields the best
                    <span class="emphasis"><em>score</em></span>, where the researcher is responsible for identifying
                an appropriate <span class="emphasis"><em>scoring method</em></span>. Relationships involving
                individual aligned items from a sequence can be categorized as belonging to three
                possible types for scoring purposes:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Items from both sequences are aligned and are the same. This is called
                            a <span class="emphasis"><em>match</em></span>. If the two entire sequences are identical,
                            all item-level alignments are matches.</p></li><li class="listitem"><p>Items from both sequences are aligned but are different. This is
                            called a <span class="emphasis"><em>mismatch</em></span>. Mismatches may arise in
                            situations where they are sandwiched between matches. For example, given
                            the input sequences <span class="quote">“<span class="quote">The brown koala</span>”</span> and <span class="quote">“<span class="quote">The gray
                                koala</span>”</span>, after aligning the words <span class="quote">“<span class="quote">The</span>”</span> and
                                <span class="quote">“<span class="quote">koala</span>”</span> in the two sequences (both alignments are
                            matches), the color words sandwiched between them form an aligned
                            mismatch.</p></li><li class="listitem"><p>An item in one sequence has no corresponding item in the other
                            sequence. This is called a <span class="emphasis"><em>gap</em></span> or an
                                <span class="emphasis"><em>indel</em></span> (because it can be interpreted as either
                            an <span class="emphasis"><em>in</em></span>sertion in one sequence or a
                                <span class="emphasis"><em>del</em></span>etion from the other). Gaps are inevitable
                            where the sequences are of different lengths, so that, for example.
                            given <span class="quote">“<span class="quote">The gray koala</span>”</span> and <span class="quote">“<span class="quote">The koala</span>”</span>, the
                            item <span class="quote">“<span class="quote">gray</span>”</span> in the first sequence corresponds to a gap in
                            the second. Gaps may also occur with sequences of the same length; for
                            example, if we align <span class="quote">“<span class="quote">The brown koala lives in Australia</span>”</span>
                            with <span class="quote">“<span class="quote">The koala lives in South Australia</span>”</span>, both sequences
                            contain six words, but the most natural alignment, with a length of
                            seven items and one gap in each sequence, is: </p><div class="table"><a id="d5e99"/><p class="title"><strong>Table 1. Alignment example with gaps</strong></p><div class="table-contents"><table class="table" summary="Alignment example with gaps" border="1"><colgroup><col/><col/><col/><col/><col/><col/><col/></colgroup><tbody><tr><td>The</td><td>brown</td><td>koala</td><td>lives</td><td>in</td><td> </td><td>Australia</td></tr><tr><td>The</td><td> </td><td>koala</td><td>lives</td><td>in</td><td>South</td><td>Australia</td></tr></tbody></table></div></div><p><br class="table-break"/>
                        </p></li></ul></div><p>A common scoring method is to assign a value of <code class="sgmltag-attvalue">1</code> to
                matches, <code class="sgmltag-attvalue">-1</code> to mismatches, and <code class="sgmltag-attvalue">-1</code> to gaps. These values prefer alignments with as many matches as
                possible, and with as few mismatches and gaps as possible. But alternative scoring
                methods might, for example, assign a greater penalty to gaps than to mismatches, or
                might assign different penalties to new gaps than to continuations of existing gaps
                (this is called an <span class="emphasis"><em>affine</em></span> gap penalty).</p><p>The scoring method determines what will be identified as an optimal alignment for
                a circular reason: optimal in this context is defined as the alignment with the best
                score. This means that the selection of an appropriate scoring method during
                philological alignment should reflect the researcher’s theory of the types of
                correspondences and non-correspondences that are meaningful for identifying textual
                moments to be compared. In the examples below we have assigned a score of <code class="sgmltag-attvalue">1</code> for matches, <code class="sgmltag-attvalue">-1</code> for
                mistmatches, and <code class="sgmltag-attvalue">-2</code> for gaps. This scoring system
                prefers mismatches to gaps, and scores gaps in a linear (not affine) way.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d5e128"/>Sequence alignment algorithms</h3></div></div></div><p>A naïve, brute-force approach to sequence alignment would construct all possible
                alignments, score them, and select the ones with the best scores. This method has
                exponential complexity, which makes it unrealistic even for relatively small
                real-world alignment tasks. [<a class="xref" href="#bellman_1954">Bellman 1954</a> 2] Alternatives must
                therefore reduce the computational complexity, ideally by reducing the search space
                to exclude from consideration in advance all alignments that
                    <span class="emphasis"><em>cannot</em></span> be optimal. Where this is not possible, a
                    <span class="emphasis"><em>heuristic</em></span> method excludes from consideration in advance
                alignments that <span class="emphasis"><em>are unlikely</em></span> to be optimal. Heuristic methods
                entail a risk of inadvertently excluding an optimal alignment, but in the case of
                some computationally complex problems, a heuristic approach may be the only
                realistic way of reducing the complexity sufficiently to make the problem
                tractable.</p><p>In the case of global pairwise alignment, the Needleman Wunsch algorithm,
                described below, has been proven always to produce an optimal alignment, according
                to whatever definition of optimal the chosen scoring method instantiates. Needleman
                Wunsch is an implementation of <span class="emphasis"><em>dynamic programming</em></span>, and in the
                following two sections we first describe dynamic programming as a paradigm and then
                explain how it is employed in the Needleman Wunsch algorithm. These explanations are
                preparatory to exploring the complications that dynamic programming, both in general
                and in the context of Needleman Wunsch, pose for XSLT and how they can be
                resolved.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e137"/>Dynamic programming and the Needleman Wunsch algorithm</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d5e139"/>Dynamic programming</h3></div></div></div><p>Dynamic programming, a paradigm developed by Richard Bellman at the Rand
                Corporation in the early 1950s, makes it possible to express complex computational
                tasks as a combination of smaller, more tractable, overlapping ones.<a href="#ftn.d5e142" class="footnote" id="d5e142"><sup class="footnote">[4]</sup></a> A commonly cited example of a task that is amenable to dynamic
                programming is the computation of a Fibonacci number. Insofar as every Fibonacci
                number beyond the first two can be expressed as a function of the two immediately
                preceding Fibonacci numbers, a naïve top-down approach to computing the value of the
                    <span class="emphasis"><em>nth</em></span> Fibonacci number would start with
                    <span class="emphasis"><em>n</em></span> and compute the two preceding values. This requires
                computing all of their preceding values, which requires computing their preceding
                values, etc., which ultimately leads to computing the same values repeatedly. A
                dynamic bottom-up computation, on the other hand, would calculate each smaller
                number only once and then use those values to move up to larger numbers.<a href="#ftn.d5e148" class="footnote" id="d5e148"><sup class="footnote">[5]</sup></a></p><p>Sequence alignment meets the two requirements for a problem to be amenable to
                dynamic programming.[<a class="xref" href="#grimson">Grimson and Guttag</a>] First, it satisfies
                    <span class="emphasis"><em>optimal substructure</em></span>, which means that an optimal solution
                to a problem can be reached by determining optimal solutions to its subproblems.
                Second, it satisfies <span class="emphasis"><em>overlapping subproblems</em></span>, where
                    <span class="emphasis"><em>overlapping</em></span> means <span class="quote">“<span class="quote">common</span>”</span> or
                    <span class="quote">“<span class="quote">shared</span>”</span>, that is, that the same subproblems recur repeatedly. In
                the Fibonacci example above, the computation of a higher Fibonacci number depends on
                the computation of the two preceding numbers (optimal substructure), and the same
                preceding numbers are used repeatedly in a top-down solution (overlapping
                subproblems). In the case of pairwise sequence alignment, the Needleman Wunsch
                algorithm, discussed below, observes both optimal substructure (an optimal alignment
                is found by finding optimal alignments of subsequences) and overlapping subproblems
                (the same properties of these subsequences are reused to solve multiple
                subproblems).</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d5e159"/>The Needleman Wunsch algorithm</h3></div></div></div><p>The history of the Needleman Wunsch algorithm is described by Boes as
                follows:</p><div class="blockquote"><blockquote class="blockquote"><p>We will begin with the scoring system most commonly used when introducing the
                    Needleman-Wunsch algorithm: substitution scores for matched residues and linear
                    gap penalties. Although Needleman and Wunsch already discussed this scoring
                    system in their 1970 article [NW70], the form in which it is now most commonly
                    presented is due to Gotoh [Got82] (who is also responsible for the affine gap
                    penalties version of the algorithm). An alignment algorithm very similar to
                    Needleman-Wunsch, but developed for speech recognition, was also independently
                    described by Vintsyuk in 1968 [Vin68]. Another early author interested in the
                    subject is Sellers [Sel74], who described in 1974 an alignment algorithm
                    minimizing sequence distance rather than maximizing sequence similarity; however
                    Smith and Waterman (two authors famous for the algorithm bearing their name)
                    proved in 1981 that both procedures are equivalent [SWF81]. Therefore it is
                    clear that there are many classic papers, often a bit old, describing
                    Needleman-Wunsch and its variants using different mathematical notations. (<a class="xref" href="#boes_2014">Boes 2014</a> 14; pointers are to <a class="xref" href="#needleman_1970">Needleman and Wunsch 1970</a>,
                        <a class="xref" href="#gotoh_1982">Gotoh 1982</a>, <a class="xref" href="#vintsyuk_1968">Vintsyuk 1968</a>, <a class="xref" href="#sellers_1974">Sellers 1974</a>, and <a class="xref" href="#smith_1981">Smith et al. 1981</a>)</p></blockquote></div><p>Boes further explains that Needleman Wunsch <span class="quote">“<span class="quote">is an
                        <span class="emphasis"><em>optimal</em></span> algorithm, which means that it produces the
                    best possible solution with respect to the chosen scoring system. There [exist]
                    also non-optimal alignment algorithms, most notably the heuristic methods
                    …</span>”</span> [<a class="xref" href="#boes_2014">Boes 2014</a> 13] <span class="quote">“<span class="quote">Non-optimal</span>”</span> here means
                not that the method is <span class="emphasis"><em>incapable</em></span> of arriving at an optimal
                solution, but that it is <span class="emphasis"><em>not guaranteed</em></span> to do so.</p><p>Performing alignment according to the Needleman Wunsch dynamic programming
                algorithm entails the following steps:<a href="#ftn.d5e178" class="footnote" id="d5e178"><sup class="footnote">[6]</sup></a>
                </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Construct a grid with one of the sequences to be aligned along the
                            top, labeling the columns, and the other along the left, labeling the
                            rows.</p></li><li class="listitem"><p>Determine a scoring system. Here we score matches as <code class="sgmltag-attvalue">1</code>, mismatches as <code class="sgmltag-attvalue">-1</code>, and gaps as <code class="sgmltag-attvalue">-2</code>.</p></li><li class="listitem"><p>Insert a row at the top, below the labels, with sequential numbers
                            reflecting multiples of the gap score. For example, if the gap score
                            value is <code class="sgmltag-attvalue">-2</code>, the values would be <code class="sgmltag-attvalue">0</code>, <code class="sgmltag-attvalue">-2</code>, <code class="sgmltag-attvalue">-4</code>, etc. Starting from the <code class="sgmltag-attvalue">0</code>, assign similar values to a column inserted
                            on the left, after the row labels. By this point the grid should look like:</p><div class="table"><a id="d5e196"/><p class="title"><strong>Table 2. Initial grid for Needleman Wunsch</strong></p><div class="table-contents"><table class="table" summary="Initial grid for Needleman Wunsch" border="1"><colgroup><col/><col/><col/><col/><col/><col/><col/></colgroup><tbody><tr><td> </td><td> </td><td align="center">k</td><td align="center">o</td><td align="center">a</td><td align="center">l</td><td align="center">a</td></tr><tr><td> </td><td align="right">0</td><td align="right">-2</td><td align="right">-4</td><td align="right">-6</td><td align="right">-8</td><td align="right">-10</td></tr><tr><td>c</td><td align="right">-2</td><td> </td><td> </td><td> </td><td> </td><td> </td></tr><tr><td>o</td><td align="right">-4</td><td> </td><td> </td><td> </td><td> </td><td> </td></tr><tr><td>l</td><td align="right">-6</td><td> </td><td> </td><td> </td><td> </td><td> </td></tr><tr><td>a</td><td align="right">-8</td><td> </td><td> </td><td> </td><td> </td><td> </td></tr></tbody></table></div></div><p><br class="table-break"/></p></li><li class="listitem"><p>Starting in the upper left of the table body, where the first items of
                            the two sequences intersect, and proceeding across each row in turn,
                            from top to bottom, write a value into each cell. That value should be
                            the highest of the following three candidate values:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The value in the cell immediately above plus the gap
                                        score.</p></li><li class="listitem"><p>The value in the cell immediately to the left plus the gap
                                        score.</p></li><li class="listitem"><p>The value in the cell immediately diagonally above to the
                                        left plus the match or mismatch score, depending on whether
                                        the intersecting sequence items constitute a match or a
                                        mismatch.</p></li></ul></div><p> For example, the first cell is the intersection of the
                                <span class="quote">“<span class="quote">k</span>”</span> at the top with <span class="quote">“<span class="quote">c</span>”</span> at the left, which
                            is a mismatch, since they are different. The cell immediately above has
                            a value of <code class="sgmltag-attvalue">-2</code>, which, when augmented by the
                            gap score, yields a value of <code class="sgmltag-attvalue">-4</code>. The same is
                            true of the cell immediately to the left. The cell diagonally above and
                            to the left has a value of <code class="sgmltag-attvalue">0</code>, which, when
                            combined with the mismatch score, yields a value of <code class="sgmltag-attvalue">-1</code>. Since that is the highest value, write it
                            into the cell. Proceed across the first row, then traverse the second
                            row from left to right, etc., ending in the lower right. The completed
                            grid should look like:</p><div class="table"><a id="d5e263"/><p class="title"><strong>Table 3. Completed grid for Needleman Wunsch</strong></p><div class="table-contents"><table class="table" summary="Completed grid for Needleman Wunsch" border="1"><colgroup><col/><col/><col/><col/><col/><col/><col/></colgroup><tbody><tr><td> </td><td> </td><td align="center">k</td><td align="center">o</td><td align="center">a</td><td align="center">l</td><td align="center">a</td></tr><tr><td> </td><td align="right">0</td><td align="right">-2</td><td align="right">-4</td><td align="right">-6</td><td align="right">-8</td><td align="right">-10</td></tr><tr><td>c</td><td align="right">-2</td><td align="right">-1</td><td align="right">-3</td><td align="right">-5</td><td align="right">-7</td><td align="right">-9</td></tr><tr><td>o</td><td align="right">-4</td><td align="right">-3</td><td align="right">0</td><td align="right">-2</td><td align="right">-4</td><td align="right">-6</td></tr><tr><td>l</td><td align="right">-6</td><td align="right">-5</td><td align="right">-2</td><td align="right">-1</td><td align="right">-1</td><td align="right">-3</td></tr><tr><td>a</td><td align="right">-8</td><td align="right">-7</td><td align="right">-4</td><td align="right">-1</td><td align="right">-2</td><td align="right">0</td></tr></tbody></table></div></div><p><br class="table-break"/> We fill the cells in the specified order because each cell
                            depends on two values from the row above (the cell immediately above and
                            the one diagonally above and to the left) and the preceding cell of the
                            same row. Filling in the cells from left to right and top to bottom
                            ensures that these values will be available when needed. For reasons
                            discussed below, these ordering dependencies pose a challenge for an
                            XSLT implementation.</p></li><li class="listitem"><p>Starting in the lower right corner, trace back through the sources
                            that determined the score of each cell. For example, the <code class="sgmltag-attvalue">0</code> value in the lower right inherited from the
                            upper diagonal left because the <code class="sgmltag-attvalue">-1</code> that was
                            there plus the match score of <code class="sgmltag-attvalue">1</code> yielded a
                                <code class="sgmltag-attvalue">0</code>, and that value was higher than the
                            scores coming from the cell immediately above (<code class="sgmltag-attvalue">-3</code> plus the gap score of <code class="sgmltag-attvalue">-2</code>
                            yields <code class="sgmltag-attvalue">-5</code>) or to immediately to the left
                                (<code class="sgmltag-attvalue">-2</code> plus the gap score of <code class="sgmltag-attvalue">-2</code> yields <code class="sgmltag-attvalue">-4</code>). In
                            the following image we have 1) added arrows indicating the source of
                            each value entered into the grid and 2) shaded match cells green and
                            mismatch cells pink: </p><div class="figure"><a id="d5e327"/><p class="title"><strong>Figure 1. Completed alignment grid</strong></p><div class="figure-contents"><div class="mediaobject"><img src="../../images/completed_grid.png" alt="Completed alignment grid"/></div></div></div><p><br class="figure-break"/></p></li><li class="listitem"><p>At each step along this traceback path, starting from the lower right,
                            if the step is diagonal and up, align one item from the end of each
                            sequence. If the step is to the left, align an item from the sequence at
                            the top with a gap (that is, do not select an item from the sequence at
                            the left). If the step is up, align an item from the sequence at the
                            left with a gap. In case of ties, the choices with the highest value are
                            all optimal and can be pursued as alternatives. In the present case,
                            this process produces the following single optimal alignment: </p><div class="figure"><a id="d5e334"/><p class="title"><strong>Figure 2. Alignment table</strong></p><div class="figure-contents"><div class="mediaobject"><img src="../../images/completed_alignment.png" alt="Alignment table"/></div></div></div><p><br class="figure-break"/></p></li></ol></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e339"/>The challenges of dynamic programming and XSLT</h2></div></div></div><p>XSLT, at least before version 3.0, plays poorly with dynamic programming because each
            step in a dynamic programming algorithm depends on values calculated at preceding steps.
            Functional programming of the sort supported by XSLT <code class="sgmltag-element">&lt;xsl:for-each&gt;</code>
            does not have access to these incremental values; if we try to run
                <code class="sgmltag-element">&lt;xsl:for-each&gt;</code> over all of the cells and populate them according to
            the values before and above them, those neighboring values will be the values in place
            initially, that is, null. The reason is that <code class="sgmltag-element">&lt;xsl:for-each&gt;</code> is not an
            iterative instruction: it <span class="emphasis"><em>orders the output</em></span> according to the input
            sequence, but it does not necessarily <span class="emphasis"><em>perform the computation</em></span> in
            that order. This is a feature because it means that such instructions can be
            parallelized, since no step is dependent on the output of any other step. But it also
            means that populating the Needleman Wunsch grid in XSLT requires an alternative to
                <code class="sgmltag-element">&lt;xsl:for-each&gt;</code>.</p><p>Tennison draws our attention to this issue in her XSLT 2.0 implementations of a
            dynamic programming algorithm to calculate Levenshtein distance (<a class="xref" href="#tennison_2007a">Tennison 2007a</a>, <a class="xref" href="#tennison_2007b">Tennison 2007b</a>), and with respect to
            constructing the grid, the algorithms for Levenshtein and Needleman Wunsch are
            analogous. The principal difference is that Levenshtein cares only about the value of
            the lower right cell, and therefore does not require the traceback steps that Needleman
            Wunsch uses to perform the alignment of actual sequence items.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d5e351"/>Why recursion breaks</h3></div></div></div><p>The traditional way to mimic updating a variable incrementally in XSLT is with
                recursion, cycling the newly updated value into each recursive call. The challenge
                to this approach is that deep recursion can consume enough memory to overflow the
                available stack space and crash the operation. XSLT processors can work around this
                limitation with <span class="emphasis"><em>tail call optimization</em></span>, which enables the
                processor to reduce the consumption of stack space by recognizing when stack values
                do not have to be preserved. Tail call optimization is finicky, however, first
                because not all XSLT implementations support it, second because functions have to be
                written in a particular way to make it possible, and third because some operations
                that can be understood as tail recursive may not look that way to the processor, and
                may therefore fail to be optimized.</p><p>The important insight with respect to recursion in Tennison’s second engagement
                with the Levenshtein problem (<a class="xref" href="#tennison_2007b">Tennison 2007b</a>) is that it is
                possible to construct the grid values for Levenshtein (and therefore also for
                Needleman Wunsch) without recurring on every cell. By writing values into the grid
                on the diagonal, instead of across each row in turn, as is traditional, Tennison is
                able to calculate all values on an individual diagonal at the same time, since the
                cells on diagonals that run from top right to bottom left have no mutual dependencies.<a href="#ftn.d5e357" class="footnote" id="d5e357"><sup class="footnote">[7]</sup></a> The absence of dependencies within a diagonal means that Tennison can
                use <code class="sgmltag-element">&lt;xsl:for-each&gt;</code>, instead of recursion, to compute all of the
                values within each diagonal, and recur only as she moves to a new diagonal. The
                computational complexity of populating the grid remains <span class="emphasis"><em>O(mn)</em></span>
                (that is, essentially quadratic), since it is still necessary to calculate values
                for each cell individually, and the total number of cells is the product of the
                lengths of the two sequences, but Tennison’s implementation reduces the recursion
                from the number of cells to the number of diagonals, which is <span class="emphasis"><em>n + m -
                    1</em></span>, that is, linear with respect to the total number of items in the
                two sequences. This implementation also reduces the storage complexity; because each
                diagonal depends only on the two immediately preceding ones, the recursive steps do
                not have to pass forward the entire state of the grid. The substantial improvement
                in computational efficiency that results from an implementation <span class="quote">“<span class="quote">on the
                    diagonal</span>”</span> was identified initially by <a class="xref" href="#wang_2002">Wang 2002</a> (8) and
                then explored further by <a class="xref" href="#naveed_2005">Naveed et al. 2005</a> (3–4), but although Wang
                first reported that items on the diagonal could be processed in parallel, it was
                Tennison who recognized that this observation could also be used to reduce the depth
                of recursion in XSLT.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d5e365"/>Iteration to the rescue</h3></div></div></div><p>Tennison’s diagonal implementation reduces the depth of recursion, but does not
                eliminate recursion entirely: because the values in each diagonal continue to depend
                on the values in the two immediately preceding diagonals, it nonetheless requires
                recursion on each new diagonal. The reduction in the depth of recursion from
                quadratic to linear scales impressively; for example, with two 20-item sequences and
                400 cells, the traditional method would have recurred 400 times, while the diagonal
                method makes only 39 function calls. In XSLT 3.0, however, it is possible to use
                    <code class="sgmltag-element">&lt;xsl:iterate&gt;</code> to avoid recursive coding entirely:</p><div class="blockquote"><blockquote class="blockquote"><p>[xsl:iterate] is similar to xsl:for-each, except that the items in the
                        input sequence are processed sequentially, and after processing each item in
                        the input sequence it is possible to set parameters for use in the next
                        iteration. It can therefore be used to solve problems that in XSLT 2.0
                        require recursive functions or templates. (<a class="xref" href="#saxon_iterate">Saxon xsl:iterate</a>)</p></blockquote></div><p> The use of <code class="sgmltag-element">&lt;xsl:iterate&gt;</code>, which was not part of the
                XSLT 2.0 that was available to Tennison in 2007, in place of the recursion that she
                was forced to retain thus observes her wise recommendation to <span class="quote">“<span class="quote">try to iterate
                    rather than recurse whenever you can</span>”</span> (<a class="xref" href="#tennison_2007b">Tennison 2007b</a>).
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d5e375"/>Processing the diagonal</h3></div></div></div><p>The classic description of Needleman Wunsch differs from Levenshtein by requiring
                that the entire grid be available at the end of its construction so that it can be
                traversed backwards to perform the actual item alignment (Levenshtein cares only
                about the final value), but the two algorithms agree in the fact that cells on each
                consecutive diagonal can be constructed using information from only the two
                immediately preceding diagonals. Within our <code class="code">&lt;xsl:iterate&gt;</code>
                instruction we return these two preceding diagonals as parameters called
                    <code class="code">$ult</code> (immediately preceding) and <code class="code">$penult</code> (preceding
                    <code class="code">$ult</code>), promoting the previous <code class="code">$ult</code> to the new
                    <code class="code">$penult</code> on each iteration and adding the current diagonal as the
                new <code class="code">$ult</code>. We improve the retrieval of these preceding cells while
                computing new values by using <code class="sgmltag-element">&lt;xsl:key&gt;</code> with a composite <code class="sgmltag-attribute">@use</code> attribute that indexes the two diagonals that
                constitute the search space according to the <code class="sgmltag-attribute">@row</code> and
                    <code class="sgmltag-attribute">@col</code> attribute values of each cell. At a minimum,
                each new cell holds information, in attributes, about its row, column, and score
                (all used to compute the values of subsequent cells) and the prior cell that was
                used to determine that score (diagonal, up, or left; used for the backward tracing
                of the path once construction has been completed); we also store some additional
                values, which we discuss below.</p><p>It is possible for more than one neighboring cell to tie for highest value, and
                because the task that motivated this development required only
                    <span class="emphasis"><em>an</em></span> optimal alignment, and not <span class="emphasis"><em>all</em></span> such
                alignments, we record only one optimal path to each cell, resolving ties by
                arbitrarily favoring diagonal, then left, and only then upper sources. There is,
                however, nothing about the method that would prohibit recording and later processing
                multiple paths, and thus identifying all optimal alignments.</p><p>In the Needleman Wunsch (and also Levenshtein) context, as <a class="xref" href="#wang_2002">Wang 2002</a> and <a class="xref" href="#naveed_2005">Naveed et al. 2005</a> point out, all values on
                the same diagonal can be calculated in parallel, and Tennison’s use of
                    <code class="sgmltag-element">&lt;xsl:for-each&gt;</code> in her improved code, in <a class="xref" href="#tennison_2007b">Tennison 2007b</a>, to process the diagonal is compatible with this
                observation because <code class="sgmltag-element">&lt;xsl:for-each&gt;</code> can be parallelized. Whether it
                    <span class="emphasis"><em>is</em></span> executed in parallel, however, is often unpredictable,
                since standard XSLT 3.0 does not give the programmer explicit control over processes
                or threads in the same way as other languages (cf. Python’s
                    <code class="code">multiprocessing</code> module). However, <span class="application">Saxon
                    EE</span> (although not <span class="application">PE</span> or
                    <span class="application">HE</span>) provides a custom <code class="sgmltag-attribute">@saxon:threads</code> attribute that allows the developer to specify that an
                    <code class="sgmltag-element">&lt;xsl:for-each&gt;</code> element should be processed in parallel. The
                documentation explains that: </p><div class="blockquote"><blockquote class="blockquote"><p>This attribute may be set on the xsl:for-each instruction. The value must
                        be an integer. When this attribute is used with Saxon-EE, the items selected
                        by the select expression of the instruction are processed in parallel, using
                        the specified number of threads. (<a class="xref" href="#saxon_threads">Saxon saxon:threads</a>)</p></blockquote></div><p> The <span class="application">Saxon</span> documentation adds, however,
                that: </p><div class="blockquote"><blockquote class="blockquote"><p>Processing using multiple threads can take advantage of multi-core CPUs.
                        However, there is an overhead, in that the results of processing each item
                        in the input need to be buffered. The overhead of coordinating multiple
                        threads is proportionally higher if the per-item processing cost is low,
                        while the overhead of buffering is proportionally higher if the amount of
                        data produced when each item is processed is high. Multi-threading therefore
                        works best when the body of the xsl:for-each instruction performs a large
                        amount of computation but produces a small amount of output. (<a class="xref" href="#saxon_threads">Saxon saxon:threads</a>)</p></blockquote></div><p>The computation of a cell score produces a small amount of output, but it also
                involves only a small amount of computation (compared to read/write memory
                operations).</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d5e413"/>Save yourself a trip … and some space</h3></div></div></div><p>The process of constructing the scoring grid for Needleman Wunsch on the diagonal
                is identical to that of constructing the grid for Levenshtein, but, as was noted
                above, the key difference is what happens next: Levenshtein cares only about the
                value of the lower right cell, and therefore does not need to walk back through the
                grid the way Needleman Wunsch does to align the actual sequences. This means that a
                diagonal implementation for a Levenshtein distance calculation can throw away each
                diagonal once it is no longer needed, and the one-cell diagonal at the lower right
                will contain the one piece of information the function is expected to return: the
                distance between the two sequences. An implementation of Needleman Wunsch according
                to the classic description of the method, however, cannot economize on space in this
                way, which means that although Needleman Wunsch and Levenshtein have comparable
                    <span class="emphasis"><em>computational</em></span> complexity, classic Needleman Wunsch has
                quadratic <span class="emphasis"><em>storage</em></span> complexity because it preserves and passes
                along the entire grid, while Tennison’s diagonal Levenshtein implementation has
                linear storage complexity because it throws away diagonals as soon as it no longer
                needs them.</p><p>The storage requirements of Needleman Wunsch are quadratic, however, only as long
                as the entire grid must be preserved for backward traversal at the end of the
                construction process, and the only information needed for that traversal is the
                direction (diagonal, left, up) of the optimal path steps. At each step along that
                traversal we do not need to know the score and we do not need the row and column
                labels. This means that we can avoid the backward traversal of the grid entirely if
                we write the cumulative full path to each cell into the cell alongside its score,
                instead just the source of the most recent path step, so that the lower right cell
                will already contain information about the full path that led to it. We can then use
                those directional path steps to construct an alignment table on the basis of the
                original sequences, without further reference to the grid. Avoiding the backwards
                trip through the grid comes at the cost of writing full path information into every
                cell during the construction of the grid, which entails extra computation and
                storage, even though we will ultimately use this information only from the one lower
                right cell for the final traversal. In compensation for storing that additional
                information in the cells, though, we no longer need to pass the entire cumulative
                grid through the iterations, so the additional paths must be stored only for the
                three-diagonal life cycle of each cell. The section below documents the improvement
                this produces with respect to both execution time and memory requirements.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d5e419"/>Performance</h3></div></div></div><p>We implemented the method described above using vanilla XSLT 3.0 of the sort that
                can be executed in <span class="application">Saxon HE</span> without any proprietary
                extensions. As a small optimization, because each cell is used an average of three
                times to compute new cell values (once each as diagonal, left, and upper), and the
                left and upper behaviors are the same (sum the score of the cell and the gap
                penalty), we perform that sum operation just once and store it when the cell is
                created, instead of computing it twice on the two occasions when it is used.</p><p>We then revised the code for <span class="application">Saxon EE</span> with two further
                types of modification: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>We use the <code class="sgmltag-attribute">@saxon:threads</code> attribute with
                            a somewhat arbitrary value of <code class="sgmltag-attvalue">10</code> on our <code class="sgmltag-element">xsl:for-each</code> elements. This ensures that the
                            body of the <code class="sgmltag-element">xsl:for-each</code> element will be
                            parallelized (although regardless of the value of the <code class="sgmltag-attribute">@saxon:threads</code> attribute, the number of
                            computations that can actually be performed simultaneously depends on
                            the number of cores provided by the CPU and on other demands on CPU
                            resources). We expect this modification, which takes advantage of
                            multiprocessing, to reduce wall time by a constant factor, where the
                            extent of the performance improvement depends on the amount of time the
                            program spends executing the <code class="sgmltag-element">&lt;xsl:for-each
                                saxon:threads="10"&gt;</code> instruction.</p></li><li class="listitem"><p>We use schema-aware processing with type annotations (using the <code class="sgmltag-attribute">@type</code> attribute) on the temporary <code class="sgmltag-element">&lt;cell&gt;</code> attributes that are used in
                            computation, which means principally the <code class="sgmltag-attribute">@row</code> and <code class="sgmltag-attribute">@col</code> (column)
                            attributes, which we type as <code class="sgmltag-attvalue">xs:integer</code>. By
                            default attributes on elements that do not undergo validation are typed
                            as <code class="sgmltag-attvalue">xs:untypedAtomic</code>, and without our
                            explicit typing we had to convert them explicitly to numerical values on
                            some occasions when we needed to operate with them. Typing them as they
                            are created and preserving the typing removes the need to cast them
                            explicitly as numbers later.<a href="#ftn.d5e442" class="footnote" id="d5e442"><sup class="footnote">[8]</sup></a> The reduction in processing that results from not having to
                            perform explicit casting must be balanced against the overhead of
                            performing schema validation (or, perhaps more accurately, type
                            validation).</p></li></ul></div><p>To explore the performance and scalability of the implementations we conducted
                word-level alignment on portions of Chapter 1 of the 1859 and 1860 (first and
                second) editions of Charles Darwin’s <em class="citetitle">On the origin of
                species</em>, which we copied from <em class="citetitle">Darwin online</em>
                    (<a class="link" href="http://darwin-online.org.uk/" target="_top">http://darwin-online.org.uk/</a>). We chose these editions to
                simplify the simulation of natural testing circumstances across different quantities
                of text. Specifically, these chapters have the same number of paragraphs, and the
                paragraphs observe the same order with respect to their overall content, although
                there are small differences in wording within the paragraphs. (This is not the case
                consistently with later editions, which deviate more substantially from one
                another.) This means that we can scale the quantity of text while always working
                with a natural comparison by specifying the number of paragraphs (rather than the
                number of words) to align. We ran the <span class="application">Saxon EE</span> (v.
                9.9.1.5J) and <span class="application">HE</span> (v. 9.9.1.4J) transformations from the
                command line with the following commands, respectively: <code class="code">java -Xms24G -Xmx24G
                    -jar /Users/djb/bin/saxon_ee/saxon9ee.jar -sa -it -o:/dev/null -repeat:10
                    nw_ee.xsl</code> and <code class="code">java -Xms24G -Xmx24G -jar
                    /Users/djb/bin/saxon_he/saxon9he.jar -it -repeat:10 -o:/dev/null
                    nw_he.xsl</code>. These instructions make 24G of RAM available to Java and cause
                Saxon to perform the specified transformation 10 times and report the average
                execution time of the last 6 runs. The testing platform was a mid-2018 MacBook Pro
                with a 2.9 GHz Intel Core i9 processor (6 physical and 12 logical cores) and 32 GB
                2400 MHz DDR4 RAM. Times are in milliseconds. The <span class="quote">“<span class="quote">N/A</span>”</span> values in the
                table below reflect processing that crashed with Java memory errors; see below for
                discussion. The table below shows the EE and HE processing time (total and ms per
                token); it reports on the time EE requires to output not just the alignment table,
                but also the full alignment grid; and it compares the EE and HE times
                directly.</p><p>
                </p><div class="table"><a id="d5e455"/><p class="title"><strong>Table 4. Comparison of EE and HE performance</strong></p><div class="table-contents"><table class="table" summary="Comparison of EE and HE performance" border="1"><colgroup><col class="col1"/><col class="col2"/><col class="col3"/><col class="col4"/><col class="col5"/><col class="col6"/><col class="col7"/><col class="col8"/><col class="col9"/><col class="col10"/><col class="col11"/><col class="col12"/></colgroup><thead><tr><th colspan="4" align="center">Tokens</th><th colspan="5" align="center">EE</th><th colspan="3" align="center">HE</th></tr><tr><th align="center">Paras</th><th align="center">1859 tokens</th><th align="center">1860 tokens</th><th align="center">total tokens</th><th align="center">time</th><th align="center">ms per token</th><th align="center">time with grid</th><th align="center">ms per token with grid</th><th align="center">grid cost</th><th align="center">time</th><th align="center">ms per token</th><th align="center">EE vs HE</th></tr></thead><tbody><tr><td align="right">1</td><td align="right">193</td><td align="right">194</td><td align="right">387</td><td align="right">567</td><td align="right">1.5</td><td align="right">880</td><td align="right">2.3</td><td align="right">155%</td><td align="right">669</td><td align="right">1.7</td><td align="right">84.8%</td></tr><tr><td align="right">2</td><td align="right">232</td><td align="right">233</td><td align="right">465</td><td align="right">751</td><td align="right">1.6</td><td align="right">1221</td><td align="right">2.6</td><td align="right">163%</td><td align="right">641</td><td align="right">1.4</td><td align="right">117.1%</td></tr><tr><td align="right">3</td><td align="right">679</td><td align="right">683</td><td align="right">1362</td><td align="right">4740</td><td align="right">3.5</td><td align="right">11898</td><td align="right">8.7</td><td align="right">251%</td><td align="right">5498</td><td align="right">4.0</td><td align="right">86.2%</td></tr><tr><td align="right">4</td><td align="right">772</td><td align="right">777</td><td align="right">1549</td><td align="right">6464</td><td align="right">4.2</td><td align="right">14903</td><td align="right">9.6</td><td align="right">231%</td><td align="right">6627</td><td align="right">4.3</td><td align="right">97.5%</td></tr><tr><td align="right">5</td><td align="right">810</td><td align="right">815</td><td align="right">1625</td><td align="right">7082</td><td align="right">4.4</td><td align="right">15031</td><td align="right">9.2</td><td align="right">212%</td><td align="right">7389</td><td align="right">4.5</td><td align="right">95.8%</td></tr><tr><td align="right">6</td><td align="right">942</td><td align="right">947</td><td align="right">1889</td><td align="right">9573</td><td align="right">5.1</td><td align="right">20599</td><td align="right">10.9</td><td align="right">215%</td><td align="right">9963</td><td align="right">5.3</td><td align="right">96.1%</td></tr><tr><td align="right">7</td><td align="right">1187</td><td align="right">1193</td><td align="right">2380</td><td align="right">15437</td><td align="right">6.5</td><td align="right">N/A</td><td align="right">N/A</td><td align="right">N/A</td><td align="right">17501</td><td align="right">7.4</td><td align="right">88.2%</td></tr><tr><td align="right">8</td><td align="right">1363</td><td align="right">1369</td><td align="right">2732</td><td align="right">22007</td><td align="right">8.1</td><td align="right">N/A</td><td align="right">N/A</td><td align="right">N/A</td><td align="right">26263</td><td align="right">9.6</td><td align="right">83.8%</td></tr><tr><td align="right">9</td><td align="right">1583</td><td align="right">1589</td><td align="right">3172</td><td align="right">29636</td><td align="right">9.3</td><td align="right">N/A</td><td align="right">N/A</td><td align="right">N/A</td><td align="right">36266</td><td align="right">11.4</td><td align="right">81.7%</td></tr><tr><td align="right">10</td><td align="right">1676</td><td align="right">1682</td><td align="right">3358</td><td align="right">32570</td><td align="right">9.7</td><td align="right">N/A</td><td align="right">N/A</td><td align="right">N/A</td><td align="right">41517</td><td align="right">12.4</td><td align="right">78.5%</td></tr><tr><td align="right">11</td><td align="right">1908</td><td align="right">1912</td><td align="right">3820</td><td align="right">44568</td><td align="right">11.7</td><td align="right">N/A</td><td align="right">N/A</td><td align="right">N/A</td><td align="right">54075</td><td align="right">14.2</td><td align="right">82.4%</td></tr><tr><td align="right">12</td><td align="right">2233</td><td align="right">2239</td><td align="right">4472</td><td align="right">63820</td><td align="right">14.3</td><td align="right">N/A</td><td align="right">N/A</td><td align="right">N/A</td><td align="right">67932</td><td align="right">15.2</td><td align="right">93.9%</td></tr><tr><td align="right">13</td><td align="right">2659</td><td align="right">2663</td><td align="right">5322</td><td align="right">96120</td><td align="right">18.1</td><td align="right">N/A</td><td align="right">N/A</td><td align="right">N/A</td><td align="right">98069</td><td align="right">18.4</td><td align="right">98.0%</td></tr><tr><td align="right">14</td><td align="right">2966</td><td align="right">2974</td><td align="right">5940</td><td align="right">120520</td><td align="right">20.3</td><td align="right">N/A</td><td align="right">N/A</td><td align="right">N/A</td><td align="right">124798</td><td align="right">21.0</td><td align="right">96.6%</td></tr><tr><td align="right">15</td><td align="right">3147</td><td align="right">3126</td><td align="right">6273</td><td align="right">134375</td><td align="right">21.4</td><td align="right">N/A</td><td align="right">N/A</td><td align="right">N/A</td><td align="right">138405</td><td align="right">22.1</td><td align="right">97.1%</td></tr></tbody></table></div></div><p><br class="table-break"/>
            </p><p>The chart below compares EE and HE performance.</p><div class="figure"><a id="d5e685"/><p class="title"><strong>Figure 3. Performance with Saxon EE and HE</strong></p><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="100%"><tr><td><img src="../../images/performance.png" width="540" alt="Performance with Saxon EE and HE"/></td></tr></table></div></div></div><p><br class="figure-break"/></p><p>Except with a very small number of tokens, EE runs the same operation as HE more
                quickly, but the effect of the relative difference in execution time diminishes as
                the volume of input grows. This behavior is consistent with the fact that 1) the
                effect of parallelization, which is the principal difference between the two
                implementations, is dependent on the number of cores, which is both small and
                constant; 2) parallelization of <code class="sgmltag-element">&lt;xsl:for-each&gt;</code>
                satisfies the <span class="quote">“<span class="quote">small amount of output</span>”</span> condition for optimal use of the
                    <code class="sgmltag-attribute">@saxon:threads</code> attribute, but not the <span class="quote">“<span class="quote">large
                    amount of computation</span>”</span> one; and 3) the number of cells, which is the same
                in both implementations, is the principal factor that determines execution time, and
                it increases quadratically, asymptotically minimizing any constant benefit provided
                by the limited opportunity for parallelization. The fact that the storage
                requirement scales linearly (as long as we do not attempt to maintain the entire
                grid) means that it is possible to align long sequences without overflowing the
                available memory, but the quadratic execution time means that the alignment of long
                sequences is nonetheless not well suited for real-time interactive processing.<a href="#ftn.d5e695" class="footnote" id="d5e695"><sup class="footnote">[9]</sup></a></p><p>The traditional Needleman Wunsch method requires composing the entire grid in
                order to traverse it backwards to perform the alignment. Because the size of the
                grid grows quadratically, this scales poorly, and the poor scaling, which is
                primarily an inconvenience with respect to processing time, quickly turns fatal with
                respect to storage. When asked to compose and maintain the entire grid (instead of
                just the alignment that can be computed on the diagonal), <span class="application">Saxon
                    EE</span> eventually crashed with a Java memory error, which a larger
                Java <code class="code">-Xmx</code> parameter could forestall, but not prevent. If the entire
                grid is an output requirement with a large amount of data, then, it will have to be
                output in a way that does not require it to be stored in memory in its entirety.
                Fortunately, as this implementation demonstrates, aligning the sequences does not
                require simultaneous access to the entire grid.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e702"/>Conclusions</h2></div></div></div><p>The code underlying this report is available at <a class="link" href="https://github.com/djbpitt/xstuff/tree/master/nw" target="_top">https://github.com/djbpitt/xstuff/tree/master/nw</a>, and has not been
            reproduced here. It is densely commented, and thus offers tutorial information about the
            method. Small exploratory stylesheets that were used to develop individual components of
            the code have been retained in a <span class="emphasis"><em>scratch</em></span> subdirectory.</p><p>Tennison concludes her second, improved computation of Levenshtein distance by writing
            that:</p><div class="blockquote"><blockquote class="blockquote"><p>I guess the take-home messages are: (a) try to iterate rather than recurse
                    whenever you can and (b) don’t blindly adapt algorithms designed for procedural
                    programming languages to XSLT. [<a class="xref" href="#tennison_2007b">Tennison 2007b</a>]</p></blockquote></div><p>The XSLT 3.0 <code class="sgmltag-element">&lt;xsl:iterate&gt;</code> element provides a robust method to
            iterate reliably that was not available to Tennison in 2007. Beyond that, as we extend
            Tennison’s XSLT-idiomatic implementation of a Levenshtein distance algorithm to the
            closely related domain of Needleman Wunsch sequence alignment, we avoid the need to
            maintain and traverse the entire grid that is part of the standard description of the
            algorithm, thus reducing the storage requirement from quadratic to linear.</p></div><div class="bibliography"><div class="titlepage"><div><div><h2 class="title"><a id="d5e714"/>Works cited</h2></div></div></div><div class="bibliomixed"><a id="bellman_1952"/><p class="bibliomixed">[Bellman 1952] Bellman, Richard E. 1952.
                <span class="quote">“<span class="quote">On the theory of dynamic programming.</span>”</span>
            <span class="citetitle"><em class="citetitle">Proceedings of the National Academy of Sciences</em></span> 38(8):716–19.
                <a class="link" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1063639/" target="_top">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1063639/</a></p></div><div class="bibliomixed"><a id="bellman_1954"/><p class="bibliomixed">[Bellman 1954] Bellman, Richard E. <span class="quote">“<span class="quote">The
                theory of dynamic programming.</span>”</span> Technical report P-550. Santa Monica: Rand
            Corporation. <a class="link" href="http://smo.sogang.ac.kr/doc/bellman.pdf" target="_top">http://smo.sogang.ac.kr/doc/bellman.pdf</a></p></div><div class="bibliomixed"><a id="boes_2014"/><p class="bibliomixed">[Boes 2014] Boes, Olivier. 2014. <span class="quote">“<span class="quote">Improving
                the Needleman-Wunsch algorithm with the DynaMine predictor.</span>”</span> Master in
            Bioinformatics thesis, Université libre de Bruxelles. <a class="link" href="http://t.ly/rzxZZ" target="_top">http://t.ly/rzxZZ</a></p></div><div class="bibliomixed"><a id="collatex"/><p class="bibliomixed">[CollateX] CollateX—software for collating textual
            sources. <a class="link" href="https://collatex.net/" target="_top">https://collatex.net/</a></p></div><div class="bibliomixed"><a id="fv_reader"/><p class="bibliomixed">[Frankenstein variorum reader] <span class="quote">“<span class="quote">Mary
                Shelley’s Frankenstein. A digital variorum edition.</span>”</span>
            <a class="link" href="http://frankensteinvariorum.library.cmu.edu/viewer/" target="_top">http://frankensteinvariorum.library.cmu.edu/viewer/</a>. See also the
            project GitHub repo at <a class="link" href="https://github.com/FrankensteinVariorum/" target="_top">https://github.com/FrankensteinVariorum/</a>.</p></div><div class="bibliomixed"><a id="snip"/><p class="bibliomixed">[Global alignment] <span class="quote">“<span class="quote">Global alignment.
                Needleman-Wunsch.</span>”</span> Chapter 9 of Pairwise alignment, Bioinformatics Lessons at
            your convenience, Snipacademy. <a class="link" href="https://binf.snipcademy.com/lessons/pairwise-alignment/global-needleman-wunsch" target="_top">https://binf.snipcademy.com/lessons/pairwise-alignment/global-needleman-wunsch</a></p></div><div class="bibliomixed"><a id="gothenburg"/><p class="bibliomixed">[Gothenburg model] <span class="quote">“<span class="quote">The Gothenburg
                model.</span>”</span> Section 1 of the documentation for <a class="xref" href="#collatex">CollateX</a>. <a class="link" href="https://collatex.net/doc/#gothenburg-model" target="_top">https://collatex.net/doc/#gothenburg-model</a></p></div><div class="bibliomixed"><a id="gotoh_1982"/><p class="bibliomixed">[Gotoh 1982] Gotoh, Osamu. 1982. <span class="quote">“<span class="quote">An
                improved algorithm for matching biological sequences.</span>”</span>
            <span class="citetitle"><em class="citetitle">Journal of molecular biology</em></span> 162(3):705–08. <a class="link" href="http://www.genome.ist.i.kyoto-u.ac.jp/~aln_user/archive/JMB82.pdf" target="_top">http://www.genome.ist.i.kyoto-u.ac.jp/~aln_user/archive/JMB82.pdf</a></p></div><div class="bibliomixed"><a id="grimson"/><p class="bibliomixed">[Grimson and Guttag] Grimson, Eric and John Guttag.
                <span class="quote">“<span class="quote">Dynamic programming: overlapping subproblems, optimal substructure.</span>”</span>
            Part 13 of <span class="citetitle"><em class="citetitle">Introduction to computer science and programming</em></span>,
            Massachusetts Institute of Technology, MIT Open Courseware. <a class="link" href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-00-introduction-to-computer-science-and-programming-fall-2008/video-lectures/lecture-13/" target="_top">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-00-introduction-to-computer-science-and-programming-fall-2008/video-lectures/lecture-13/</a>
        </p></div><div class="bibliomixed"><a id="intertextual_dante"/><p class="bibliomixed">[Intertextual Dante] 
            <span class="quote">“<span class="quote">Intertextual Dante.</span>”</span>
            <a class="link" href="https://digitaldante.columbia.edu/intertexual-dante-vanpeteghem/" target="_top">https://digitaldante.columbia.edu/intertexual-dante-vanpeteghem/</a>
        </p></div><div class="bibliomixed"><a id="juxta"/><p class="bibliomixed">[Juxta] Juxta. <a class="link" href="https://www.juxtasoftware.org/" target="_top">https://www.juxtasoftware.org/</a></p></div><div class="bibliomixed"><a id="kay_2008"/><p class="bibliomixed">[Kay 2008] Kay, Michael. 2008. <span class="citetitle"><em class="citetitle">XSLT 2.0
                and XPath 2.0 programmer’s reference.</em></span> 4th edition. Indianapolis: Wiley
            (Wrox).</p></div><div class="bibliomixed"><a id="msa"/><p class="bibliomixed">[Multiple sequence alignment (Wikipedia)] Multiple
            sequence alignment (Wikipedia). Accessed 2019-11-03. <a class="link" href="https://en.wikipedia.org/wiki/Multiple_sequence_alignment" target="_top">https://en.wikipedia.org/wiki/Multiple_sequence_alignment</a></p></div><div class="bibliomixed"><a id="naveed_2005"/><p class="bibliomixed">[Naveed et al. 2005] Naveed, Tahir, Imitaz Saeed
            Siddiqui, and Shaftab Ahmed. 2005. <span class="quote">“<span class="quote">Parallel Needleman-Wunsch algorithm for
                grid.</span>”</span> Proceedings of the PAK-US International Symposium on High Capacity
            Optical Networks and Enabling Technologies (HONET 2005), Islamabad, Pakistan, Dec 19–21,
            2005. <a class="link" href="https://upload.wikimedia.org/wikipedia/en/c/c4/ParallelNeedlemanAlgorithm.pdf" target="_top">https://upload.wikimedia.org/wikipedia/en/c/c4/ParallelNeedlemanAlgorithm.pdf</a></p></div><div class="bibliomixed"><a id="needleman_1970"/><p class="bibliomixed">[Needleman and Wunsch 1970] Needleman, Saul
            B. and Christian D. Wunsch. 1970. <span class="quote">“<span class="quote">A general method applicable to the search for
                similarities in the amino acid sequence of two proteins.</span>”</span>
            <span class="citetitle"><em class="citetitle">Journal of molecular biology</em></span> 48 (3): 443–53.
            doi:10.1016/0022-2836(70)90057-4.</p></div><div class="bibliomixed"><a id="saxon_threads"/><p class="bibliomixed">[Saxon saxon:threads] Saxon documentation of
                <span class="emphasis"><em>saxon:threads</em></span>. <a class="link" href="https://www.saxonica.com/html/documentation/extensions/attributes/threads.html" target="_top">https://www.saxonica.com/html/documentation/extensions/attributes/threads.html</a></p></div><div class="bibliomixed"><a id="saxon_iterate"/><p class="bibliomixed">[Saxon xsl:iterate] Saxon documentation of
                <span class="emphasis"><em>xsl:iterate</em></span>. <a class="link" href="http://www.saxonica.com/documentation/index.html#!xsl-elements/iterate" target="_top">http://www.saxonica.com/documentation/index.html#!xsl-elements/iterate</a></p></div><div class="bibliomixed"><a id="sellers_1974"/><p class="bibliomixed">[Sellers 1974] Sellers, Peter H. 1974.
                <span class="quote">“<span class="quote">On the theory and computation of evolutionary distances.</span>”</span>
            <span class="citetitle"><em class="citetitle">SIAM journal on applied mathematics</em></span> 26(4):787–93.</p></div><div class="bibliomixed"><a id="smith_1981"/><p class="bibliomixed">[Smith et al. 1981] Smith, Temple F., Michael S.
            Waterman, and Walter M. Fitch. 1981. <span class="quote">“<span class="quote">Comparative biosequence metrics.</span>”</span>
            <span class="citetitle"><em class="citetitle">Journal of molecular evolution</em></span>, 18(1):38–46. <a class="link" href="https://www.researchgate.net/publication/15863628_Comparative_biosequence_metrics" target="_top">https://www.researchgate.net/publication/15863628_Comparative_biosequence_metrics</a></p></div><div class="bibliomixed"><a id="tennison_2007a"/><p class="bibliomixed">[Tennison 2007a] Tennison, Jeni. 2007.
                <span class="quote">“<span class="quote">Levenshtein distance in XSLT 2.0.</span>”</span> Posted to <span class="citetitle"><em class="citetitle">Jeni’s
                musings</em></span>, 2007-05-03. <a class="link" href="https://www.jenitennison.com/2007/05/06/levenshtein-distance-on-the-diagonal.html" target="_top">https://www.jenitennison.com/2007/05/06/levenshtein-distance-on-the-diagonal.html</a></p></div><div class="bibliomixed"><a id="tennison_2007b"/><p class="bibliomixed">[Tennison 2007b] Tennison, Jeni. 2007.
                <span class="quote">“<span class="quote">Levenshtein distance on the diagonal.</span>”</span> Posted to <span class="citetitle"><em class="citetitle">Jeni’s
                musings</em></span>, 2007-05-06. <a class="link" href="https://www.jenitennison.com/2007/05/06/levenshtein-distance-on-the-diagonal.html" target="_top">https://www.jenitennison.com/2007/05/06/levenshtein-distance-on-the-diagonal.html</a></p></div><div class="bibliomixed"><a id="trovato_2014"/><p class="bibliomixed">[Trovato 2014] Trovato, Paolo.
                <span class="citetitle"><em class="citetitle">Everything you always wanted to know about Lachmann’s method. A
                non-standard handbook of genealogical textual criticism in the age of
                post-structuralism, cladistics, and copy-text.</em></span> Padova:
            libreriauniversitaria.it , 2014</p></div><div class="bibliomixed"><a id="peteghhem_2015"/><p class="bibliomixed">[Van Peteghem 2015] Van Peteghem, Julie.
            2015. <span class="quote">“<span class="quote">Digital readers of allusive texts: Ovidian intertextuality in the Commedia
                and the Digital concordance on intertextual Dante.</span>”</span>
            <span class="citetitle"><em class="citetitle">Humanist studies &amp; the digital age</em></span>, 4.1, 39–59. DOI:
            10.5399/uo/hsda.4.1.3584. <a class="link" href="http://journals.oregondigital.org/index.php/hsda/article/view/3584" target="_top">http://journals.oregondigital.org/index.php/hsda/article/view/3584</a></p></div><div class="bibliomixed"><a id="vintsyuk_1968"/><p class="bibliomixed">[Vintsyuk 1968] Vintsyuk, T[aras] K[lymovych].
            1968. <span class="quote">“<span class="quote">Speech discrimination by dynamic programming.</span>”</span>
            <span class="citetitle"><em class="citetitle">Cybernetics</em></span> 4(1):52–57.</p></div><div class="bibliomixed"><a id="wang_2002"/><p class="bibliomixed">[Wang 2002] Wang, Bin. 2002. <span class="quote">“<span class="quote">Implementation
                of a dynamic programming algorithm for DNA sequence alignment on the cell matrix
                architecture. MA thesis, Utah State University.</span>”</span>
            <a class="link" href="https://www.cellmatrix.com/entryway/products/pub/wang2002.pdf" target="_top">https://www.cellmatrix.com/entryway/products/pub/wang2002.pdf</a></p></div></div><div class="footnotes"><br/><hr style="width:100; text-align:left;margin-left: 0"/><div id="ftn.d5e16" class="footnote"><p><a href="#d5e16" class="para"><sup class="para">[1] </sup></a><span class="emphasis"><em>Witness</em></span>, sometimes expanded as <span class="emphasis"><em>manuscript
                            witness</em></span>, is a technical term in text-critical scholarship for
                        a manuscript that provides evidence of the history of a text.</p></div><div id="ftn.d5e20" class="footnote"><p><a href="#d5e20" class="para"><sup class="para">[2] </sup></a>For an introduction to the evaluation of shared and divergent readings as
                        a component of textual criticism see <a class="xref" href="#trovato_2014">Trovato 2014</a>.</p></div><div id="ftn.d5e67" class="footnote"><p><a href="#d5e67" class="para"><sup class="para">[3] </sup></a><a class="xref" href="#msa">Multiple sequence alignment (Wikipedia)</a> provides an overview of multiple
                                    sequence alignment, the term in bioinformatics for what
                                    philologists refer to as multiple-witness alignment.</p></div><div id="ftn.d5e142" class="footnote"><p><a href="#d5e142" class="para"><sup class="para">[4] </sup></a>For more information about dynamic programming see <a class="xref" href="#bellman_1952">Bellman 1952</a> and <a class="xref" href="#bellman_1954">Bellman 1954</a>.</p></div><div id="ftn.d5e148" class="footnote"><p><a href="#d5e148" class="para"><sup class="para">[5] </sup></a>The implementation of dynamic programming according to a bottom-up
                        organization is called <span class="emphasis"><em>tabulation</em></span>. A top-down dynamic
                        approach would perform all of the recursive computation at the beginning,
                        but <span class="emphasis"><em>memoize</em></span> (that is, store and index) the
                        sub-calculations, so that they could be looked up and reused, without having
                        to be recomputed, when needed at lower levels.</p></div><div id="ftn.d5e178" class="footnote"><p><a href="#d5e178" class="para"><sup class="para">[6] </sup></a>For a clear and more detailed explanation see <a class="xref" href="#snip">Global alignment</a>.</p></div><div id="ftn.d5e357" class="footnote"><p><a href="#d5e357" class="para"><sup class="para">[7] </sup></a>Not only are there no mutual dependencies within a diagonal, but all of
                        the information needed to process an entire diagonal is available
                        simultaneously from only the two preceding diagonals, without any dependency
                        on earlier ones. This property contributes to the scalability of our
                        implementation in ways that will be discussed below.</p></div><div id="ftn.d5e442" class="footnote"><p><a href="#d5e442" class="para"><sup class="para">[8] </sup></a>For example, we use keys to retrieve cells by row and column
                                    number, the values of which we compute, and the type of the
                                    value used to retrieve an item with a key must match the type of
                                    the value used to index it originally (<a class="xref" href="#kay_2008">Kay 2008</a> 813). Typing the row and column number as integers when they
                                    are created removes the need to cast them as numerical types for
                                    query and retrieval.</p></div><div id="ftn.d5e695" class="footnote"><p><a href="#d5e695" class="para"><sup class="para">[9] </sup></a>As a test of larger capacity, we aligned the entire first chapter of the
                        1859 and 1860 editions of <em class="citetitle">On the origin of species</em>.
                        The 49 paragraphs of the 1859 and 1860 editions contain 11590 and 11632 word
                        tokens, respectively. The total number of word tokens in the two editions is
                        23222, and there are 134814880 cells in the complete grid. The alignment,
                        using EE and the default Java memory allocation, reported real time of
                        64m43.159s, user time of 538m5.128s, and sys time of 13m25.910s. Real time
                        is lower than user time plus sys time because of parallel execution.</p><p>With respect to storage, processing maintains only a constant three
                        diagonals at a time, and the length of a diagonal is linear with respect to
                        the sum of the lengths of the sequences being compared. The lengths of the
                        full paths that are accumulated on the cells grow linearly with respect to
                        the number of diagonals, which also enjoys a linear relationship with the
                        lengths of the two sequences being aligned. The number of cells on a
                        diagonal grows, levels off, and then shrinks linearly with respect to the
                        number of tokens in the two sequences being compared; the first and last
                        diagonal each contain a single cell.</p></div></div></div></body></html>